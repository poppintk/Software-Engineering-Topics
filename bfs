
BFS
// q is Queue
q.push(start)
step = 0

while not q.empty():
	++step;
	size = q.size()
	while size != 0:
		node = q.pop()
		new_nodes = expand(node)
		if goal in new_nodes: return step + 1
		q.append(new_nodes)
return NOT_FOUND

Bidirectional BFS
// s1 and s2 are both hashSet
s1.insert(start)
s2.insert(end)
step = 0

while not(s1.empty() || s2.empty()):
	++step
	swap(s1,s2)
	s = {}
	for node in s1:
		new_nodes = expand(node)
		if any(new_nodes) in s2: return step + 1
		s.append(new_nodes)
return NOT_FOUND


127. Word Ladder

class Solution {
    public int ladderLength(String beginWord, String endWord, List<String> wordList) {
        
        Set<String> dict = new HashSet<>();
        for(String s: wordList){
            dict.add(s);
        }
        
        if(!dict.contains(endWord)) return 0;
        
        int step = 0;
        Queue<String> queue = new LinkedList<>();
        queue.add(beginWord);
        while(!queue.isEmpty()){
            ++step;
            int size = queue.size();
            // current level
            for(int i = 0; i < size; i++){
                String curString = queue.poll();
                // find next string
                char [] temp = curString.toCharArray();
                for(int j = 0; j < curString.length(); j++){
                    char old = temp[j];
                    for(char c = 'a'; c <= 'z'; c++){
                        temp[j] = c;
                        String newString = String.valueOf(temp);
                        if(newString.equals(endWord)) return step+1;
                        if(!dict.contains(newString)) continue;
                        queue.add(newString);
                        dict.remove(newString);
                    }
                    temp[j] = old;
                }   
            }
        }
        return 0;
    }
}


END 127. Word Ladder
-----------------------------------------------------------------------------------------------------------------------------
