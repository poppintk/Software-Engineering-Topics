Architecture:  master slave (Single master or Multiple master)

Feature:
-self healing
-secret management
-service discovery and load balancing
-horizontal scaling 

Use case:
 1) Microservices
 2) Lift and shift
 3) Cloud Native Network Functions
 4) Machine learning
 5) CI/CD

Components:
  Master:
    1) kubectl command line inteface 
    2) Web UI
    
    3) etcd
      - key value based database for K8S as all data cluster backend database
      - K8S cluster etcd database usually need a backup plan 
    
    4) Kube-scheduler
      - monitoring those newly created Pods and manage to schedule nodes to run Pods
      - it must use master to schedule all K8S cluster operations
    
    5) Kube-controller-manager
        a) Node Contorller: response and alert issues on the nodes
        b) Replication Controller: used for every replication controller to maintain correct number of Pods
        c) Endpoints Controller: used for adding endpoints(server or Pod)
        d) Service Account & Token Controllers: create default account and API token for the new naming space
    
    6) Kube-api server:
     Note: all components mentioned above(as well as KubeProxy, Kubelet) interacts with Kube-api
      - the entrance for external system to interact with K8S
      - provide authentication, authorization, access control and API register and discovery
        
  Node: running on a machine
    NOTE: Pods are group of containers
    
    1) Container (by default it's docker but can also use other container technology)
    2) Kubelet
      - the agent manager for Node
      - interact with container engine directly and manage container liefcycle
    3) Kube-proxy
      - provide internal service discovery and load balancer for service
      
    4) Fluentd
      - monitor for collecting logs from cluster
    
    
Pod are group of containers
Service: How we discover IP address of the individual pod(Could be cluster of pods)
Deployment: group of services
Ingress controller: load balacing<nginx implemention>

each Pod has its own IP(can use duplicated port consumed by other Pods)
each Service has its own domain(can use duplicated port consumed by other Services)
NodePort cannot be duplicated

NodePort - port exposed on the host machine(Postman can reach)
targetPort - This is the actual port on which your application is running inside the container.
port - port for service and redirect to targetPort

------------------------
ETCD Storage
 - v2 is in memory database and v3 is local database
 - K8S cluster using Etcd v3 and v2 has been deprecated in K8S v1.11


