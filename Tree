110. Balanced Binary Tree

DEPTH:
The depth of a node is the number of edges from the node to the tree's root node.
A root node will have a depth of 0.
HEIGHT:
The height of a node is the number of edges on the longest path from the node to a leaf.
A leaf node will have a height of 0.

1) preorder, inorder, post order travasal
// preorder
public void preorder(TreeNode root){
    if(root == null) return;
    System.out.println(root.val);
    preorder(root.left);
    preorder(rootright);
}

// inorder
public void preorder(TreeNode root){
    if(root == null) return;
    preorder(root.left);
    System.out.println(root.val);
    preorder(rootright);
}

// post order
public void preorder(TreeNode root){
    if(root == null) return;
    preorder(root.left);
    preorder(rootright);
    System.out.println(root.val);
}
105. Construct Binary Tree from Preorder and Inorder Traversal
preorder
     1
   /   \
  2     3 
 /     /
4     5
//practice trace
preorder : [1,2,4,3,5] prestart, preend
inorder: [4,2,1,5,3] instart, inend

inIdx = inMap.get(preorder[prestart])
leftSubTree: 
    prestart = prestart + 1, 
    preend = prestart + inIdx - instart,
    instart = instart, 
    inend = inIdx - 1;
rightSubTree: 
    prestart = prestart + inIdx - instart + 1, 
    preend = preend,
    instart = InIdx+1, 
    inend = inend;

106. Construct Binary Tree from Inorder and Postorder Traversal
     1
   /   \
  2     3 
 /     /
4     5

Postorder : [4,2,5,3,1] poststart, postend
inorder: [4,2,1,5,3] instart, inend

leftSubTree: 
    poststart = poststart
    postend = poststart + inIdx - instart -1,
    instart = instart,
    inend = inIdx - 1;
rightSubTree: 
    poststart = poststart + inIdx - instart
    postend = postend - 1, 
    instart = InIdx+1, 
    inend = inend;


236. Lowest Common Ancestor of a Binary Tree
235. Lowest Common Ancestor of a Binary Search Tree

public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if(root == null || root == p || root == q) return root;

    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);

    if(left != null && right != null){
        return root;
    }else if(left == null){
        return right;
    }else if(right == null){
        return left;
    }

    return null;
}

//116. Populating Next Right Pointers in Each Node
//117. Populating Next Right Pointers in Each Node II
 public Node connect(Node root) {
    Node head = root;
    Node dummy = new Node(-1);
    Node nextlvl = dummy;

    while(head != null){
        // constructing next level
        if(head.left != null){
            nextlvl.next = head.left;
            nextlvl = nextlvl.next;
        }
        // constructing next level
        if(head.right != null){
            nextlvl.next = head.right;
            nextlvl = nextlvl.next;
        }
        // constructing next level
        head = head.next;

        // end of the level
        if (head == null) {
            // head to next head of level
            head = dummy.next;
            // set dummy node next to null
            dummy.next = null;
            nextlvl = dummy;
        }
    }

    return root;
}

//
private void dfs(TreeNode root, List<Integer> nums, String num){
    if(root == null) return;
    if(root.left == null && root.right == null){
        nums.add(Integer.parseInt(num+root.val));
        return;
    }
    dfs(root.left,nums,num + root.val);
    dfs(root.right,nums,num + root.val);
}

1) edge case
// terminate at leaf
if(root == null) return;// edge case
if(root.left == null && root.right == null) return;
recurse(root.left);
recurse(root.right);

// terminate at null;
if(root == null) return;
recurse(root.left);
recurse(root.right);

// either one is null
if(root == null) return;// edge case
if(root.left == null && root.right == null) return;
if(root.left == null || root.right == null) return; // either one is null


257. Binary Tree Paths
112. Path Sum
113. Path Sum II
114. Flatten Binary Tree to Linked List
199. Binary Tree Right Side View
94. Binary Tree Inorder Traversal
100. Same Tree
101. Symmetric Tree
104. Maximum Depth of Binary Tree
107. Binary Tree Level Order Traversal II
110. Balanced Binary Tree
