110. Balanced Binary Tree

DEPTH:
The depth of a node is the number of edges from the node to the tree's root node.
A root node will have a depth of 0.
HEIGHT:
The height of a node is the number of edges on the longest path from the node to a leaf.
A leaf node will have a height of 0.

1) preorder, inorder, post order travasal
// preorder
public void preorder(TreeNode root){
    if(root == null) return;
    System.out.println(root.val);
    preorder(root.left);
    preorder(rootright);
}

//98. Validate Binary Search Tree
         6
       /   \
      3     8 
     / \   / \ 
    2  5  7   9
    
// keep tracking of max and min
// left update max(since left subtree less than root), right update min(since right greater than root).
public boolean recurse(TreeNode root, Integer max, Integer min){
    if(root == null) return true;
    if(min != null && root.val <= min) return false;
    if(max != null && root.val >= max) return false;
    return recurse(root.left, root.val, min) && recurse(root.right, max, root.val);
}
public boolean isValidBST(TreeNode root) {
    return recurse(root,null,null);
}

// inorder
public void preorder(TreeNode root){
    if(root == null) return;
    preorder(root.left);
    System.out.println(root.val);
    preorder(rootright);
}
// iterative inorder
public List<Integer> iterative(TreeNode root) {
    List<Integer> result = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    pushAllLeft(root,stack);
    TreeNode cur = null;
    while(!stack.isEmpty()){
        cur = stack.pop();
        result.add(cur.val);
        pushAllLeft(cur.right,stack);
    }
    return result;
}

public void pushAllLeft(TreeNode root,Stack<TreeNode> stack){
    TreeNode cur = root;
    while(cur != null){
        stack.add(cur);
        cur = cur.left;
    }
}

// post order
public void preorder(TreeNode root){
    if(root == null) return;
    preorder(root.left);
    preorder(rootright);
    System.out.println(root.val);
}
105. Construct Binary Tree from Preorder and Inorder Traversal
preorder
     1
   /   \
  2     3 
 /     /
4     5
//practice trace
preorder : [1,2,4,3,5] prestart, preend
inorder: [4,2,1,5,3] instart, inend

inIdx = inMap.get(preorder[prestart])
leftSubTree: 
    prestart = prestart + 1, 
    preend = prestart + inIdx - instart,
    instart = instart, 
    inend = inIdx - 1;
rightSubTree: 
    prestart = prestart + inIdx - instart + 1, 
    preend = preend,
    instart = InIdx+1, 
    inend = inend;

106. Construct Binary Tree from Inorder and Postorder Traversal
     1
   /   \
  2     3 
 /     /
4     5

Postorder : [4,2,5,3,1] poststart, postend
inorder: [4,2,1,5,3] instart, inend

leftSubTree: 
    poststart = poststart
    postend = poststart + inIdx - instart -1,
    instart = instart,
    inend = inIdx - 1;
rightSubTree: 
    poststart = poststart + inIdx - instart
    postend = postend - 1, 
    instart = InIdx+1, 
    inend = inend;


236. Lowest Common Ancestor of a Binary Tree
235. Lowest Common Ancestor of a Binary Search Tree

public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if(root == null || root == p || root == q) return root;

    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);

    if(left != null && right != null){
        return root;
    }else if(left == null){
        return right;
    }else if(right == null){
        return left;
    }

    return null;
}

//116. Populating Next Right Pointers in Each Node
//117. Populating Next Right Pointers in Each Node II
 public Node connect(Node root) {
    Node head = root;
    Node dummy = new Node(-1);
    Node nextlvl = dummy;

    while(head != null){
        // constructing next level
        if(head.left != null){
            nextlvl.next = head.left;
            nextlvl = nextlvl.next;
        }
        // constructing next level
        if(head.right != null){
            nextlvl.next = head.right;
            nextlvl = nextlvl.next;
        }
        // constructing next level
        head = head.next;

        // end of the level
        if (head == null) {
            // head to next head of level
            head = dummy.next;
            // set dummy node next to null
            dummy.next = null;
            nextlvl = dummy;
        }
    }

    return root;
}


1) edge case
// terminate at leaf
if(root == null) return;// edge case
if(root.left == null && root.right == null) return;
recurse(root.left);
recurse(root.right);

// terminate at null;
if(root == null) return;
recurse(root.left);
recurse(root.right);

// either one is null
if(root == null) return;// edge case
if(root.left == null && root.right == null) return;
if(root.left == null || root.right == null) return; // either one is null


129. Sum Root to Leaf Numbers
//tail recursion
private int dfs(TreeNode root, Integer sum){
    if(root == null) return 0;
    if(root.left == null && root.right == null) return sum * 10 + root.val;
    return dfs(root.left, sum * 10 + root.val) + dfs(root.right, sum * 10 + root.val);
}
//note: if case can not pass with tree like [1,0]
//then try
// if(root.left == null) return dfs(root.right, num*10 + root.val);
// if(root.right == null) return dfs(root.left, num*10 + root.val);

222. Count Complete Tree Nodes
// non tail recursion (there is log(2n) algorithm,but following solves general tree nodes problem)
public int countNodes(TreeNode root) {
    if(root == null) return 0;
    return 1 + countNodes(root.left) + countNodes(root.right);
}


112. Path Sum (base case end from leaves)
113. Path Sum II (end from leaves + backtracking on temp)

class Solution {
    public List<List<Integer>> pathSum(TreeNode root, int sum) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> path = new ArrayList<>();
        dfs(root, sum , result, path);
        return result;
    }
    public void dfs(TreeNode root, int sum,List<List<Integer>> result,List<Integer> path){
        if(root == null) return;
        if(root.left == null && root.right == null&& sum - root.val == 0){
            path.add(root.val);
            result.add(new ArrayList<>(path));
            path.remove(path.size()-1);
            return;
        }
        path.add(root.val);
        dfs(root.left, sum - root.val, result, path);
        dfs(root.right, sum - root.val, result, path);
        path.remove(path.size() -1);
    }
}


257. Binary Tree Paths


114. Flatten Binary Tree to Linked List
private TreeNode next = null;
public void flatten(TreeNode root) {
    if(root == null) return;
    flatten(root.right);
    flatten(root.left);
    // post order
    root.right = next;
    root.left = null;
    next = root;
}
124. Binary Tree Maximum Path Sum
199. Binary Tree Right Side View
94. Binary Tree Inorder Traversal
100. Same Tree
101. Symmetric Tree
104. Maximum Depth of Binary Tree
107. Binary Tree Level Order Traversal II
110. Balanced Binary Tree
