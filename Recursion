1) 

assume recursion function is: recurse(object.next);

public ListNode recurse(ListNode head){
  if(head == null || head.next == null) return head;
  
  recurse(head.next.next); // base case is head == null or head.next == null
}

2) if recursion function return something, make sure someting is return follow the same sequence.
like, if returned is head then basecase and non-basecase part should be head. 
if returned is tail then basecase and non-basecase part should be tail.
think careful through how returned value connect to previous call stack.

24. Swap Nodes in Pairs

3) Tail recursion
// non-tail recursion
function recsum(x) {
    if (x === 1) {
        return x;
    } else {
        return x + recsum(x - 1);
    }
}

//tail recursion
function tailrecsum(x, running_total = 0) {
    if (x === 0) {
        return running_total;
    } else {
        return tailrecsum(x - 1, running_total + x);
    }
}

The consequence of this is that once you are ready to perform your next recursive step, 
you don't need the current stack frame any more. This allows for some optimization. 
In fact, with an appropriately written compiler, you should never have a stack overflow snicker with a tail recursive call.
98. Validate Binary Search Tree
965. Univalued Binary Tree
653. Two Sum IV - Input is a BST
