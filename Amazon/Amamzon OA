Top K Frequently Mentioned Keywords

Given a list of reviews, a list of keywords and an integer k. Find the most popular k keywords in order of most to least frequently mentioned.
The comparison of strings is case-insensitive. If keywords are mentioned an equal number of times in reviews, sort alphabetically.

Example 1:

Input:
k = 2
keywords = ["anacell", "cetracular", "betacellular"]
reviews = [
  "Anacell provides the best services in the city",
  "betacellular has awesome services",
  "Best services provided by anacell, everyone should use anacell",
]

Output:
["anacell", "betacellular"]

Explanation:
"anacell" is occuring in 2 different reviews and "betacellular" is only occuring in 1 review.


public List<String> solve(int k, String[] keywords, String[] reviews) {
	Map<String, Integer> hm = new HashMap<>();
	for (String sentence : reviews) {
		Set<String> hs = new HashSet<>(); // Note: hashSet is used here due to in a sentence there could be more than one occurrence of word
		String[] words = sentence.split("\\W");
		for (String word : words) {
			hs.add(word.toLowerCase());
		}
		for(String word : hs){
			word = word.toLowerCase();
			hm.put(word, hm.getOrDefault(word, 0) + 1);
		}
	}
	PriorityQueue<String> pq = new PriorityQueue<>((a, b) -> hm.get(a) != hm.get(b) ? hm.get(a) - hm.get(b) : b.compareTo(a));
	for (String str : keywords) {
		str = str.toLowerCase();
		if (hm.containsKey(str)) { // keyword might not exist in reviews
			pq.offer(str); // offer() or add()
		}//if word is not in reviews need to sort alphabetically?
		if (pq.size() > k) {
			pq.poll();
		}
	}
	List<String> res = new ArrayList<>();
	while (!pq.isEmpty()) {
		res.add(pq.poll());
	}
	Collections.reverse(res);
	return res;
}

---------------------------------------------------------------------------------------------------------------------------
Min Cost to Connect All Nodes

Given an undirected graph with n nodes labeled 1..n. Some of the nodes are already connected. The i-th edge connects nodes edges[i][0] and edges[i][1] together. Your task is to augment this set of edges with additional edges to connect all the nodes. Find the minimum cost to add new edges between the nodes such that all the nodes are accessible from each other.

Input:

n, an int representing the total number of nodes.
edges, a list of integer pair representing the nodes already connected by an edge.
newEdges, a list where each element is a triplet representing the pair of nodes between which an edge can be added and the cost of addition, respectively (e.g. [1, 2, 5] means to add an edge between node 1 and 2, the cost would be 5).
Example 1:

Input: n = 6, edges = [[1, 4], [4, 5], [2, 3]], newEdges = [[1, 2, 5], [1, 3, 10], [1, 6, 2], [5, 6, 5]]
Output: 7
Explanation:
There are 3 connected components [1, 4, 5], [2, 3] and [6].
We can connect these components into a single component by connecting node 1 to node 2 and node 1 to node 6 at a minimum cost of 5 + 2 = 7.

// https://leetcode.com/discuss/interview-question/356981
Kruskal Algorithm
public class Main {
    public static void main(String[] args) {
        int n = 6;
        int[][] edges = {{1, 4}, {4, 5}, {2, 3}};
        int[][] newEdges = {{1, 2, 5}, {1, 3, 10}, {1, 6, 2}, {5, 6, 5}};
        System.out.println(minCost(n, edges, newEdges));
    }
    
    public static int minCost(int n, int[][] edges, int[][] newEdges) {
        UF uf = new UF(n + 1); // + 1 because nodes are 1-based
        for (int[] edge : edges) {
            uf.union(edge[0], edge[1]);
        }
        
        Queue<int[]> pq = new PriorityQueue<>(newEdges.length, (e1, e2) -> Integer.compare(e1[2], e2[2]));
        pq.addAll(Arrays.asList(newEdges)); // Note: syntax sugar
        
        int totalCost = 0;
        // 2 because nodes are 1-based and we have 1 unused component at index 0
        while (!pq.isEmpty() && uf.count != 2) {
            int[] edge = pq.poll();
            if (!uf.connected(edge[0], edge[1])) {
                uf.union(edge[0], edge[1]);
                totalCost += edge[2];
            }
        }
        return totalCost;
    }
}

class UF {
    private int[] parent;  // parent[i] = parent of i
    private byte[] rank;   // rank[i] = rank of subtree rooted at i (never more than 31)
    public int count;      // number of connected components

    public UF(int n) {
        if (n < 0) throw new IllegalArgumentException();
        parent = new int[n];
        rank = new byte[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
        count = n;
    }

    public int find(int p) {
        while (p != parent[p]) {
            parent[p] = parent[parent[p]];
            p = parent[p];
        }
        return p;
    }

    public void union(int p, int q) {
        int pr = find(p);
        int qr = find(q);
        if (pr == qr) return;
        if (rank[pr] < rank[qr]) {
            parent[pr] = qr;
        } else {
            parent[qr] = pr;
            if (rank[pr] == rank[qr]) rank[pr]++;
        }
        count--;
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }
}

------------------------------------------------------------------------------------------------------------------------
 Zombie in Matrix
 
 Given a 2D grid, each cell is either a zombie 1 or a human 0. Zombies can turn adjacent (up/down/left/right) human beings into zombies every hour. Find out how many hours does it take to infect all humans?

Example:

Input:
[[0, 1, 1, 0, 1],
 [0, 1, 0, 1, 0],
 [0, 0, 0, 0, 1],
 [0, 1, 0, 0, 0]]

Output: 2

Explanation:
At the end of the 1st hour, the status of the grid:
[[1, 1, 1, 1, 1],
 [1, 1, 1, 1, 1],
 [0, 1, 0, 1, 1],
 [1, 1, 1, 0, 1]]

At the end of the 2nd hour, the status of the grid:
[[1, 1, 1, 1, 1],
 [1, 1, 1, 1, 1],
 [1, 1, 1, 1, 1],
 [1, 1, 1, 1, 1]]
int minHours(int rows, int columns, List<List<Integer>> grid) {
	// todo
}

public static void main(String[] args) {
	//int[][] grid = { { 0,1,0,0}, { 0, 0, 0, 0}, { 0, 0, 0, 0 }, { 0,0, 0, 0 } };
	int[][] grid = { { 0, 1, 1, 0, 1 }, { 0, 1, 0, 1, 0 }, { 0, 0, 0, 0, 1 }, { 0, 1, 0, 0, 0 } };
    System.out.println(minDays(grid));
}

private static int minDays(int[][] grid) {
	if(grid.length == 0 || grid[0].length == 0) return -1;

	Queue<int[]> q = new LinkedList<>();
	int target = grid.length * grid[0].length;
	int cnt = 0, hour = 0;
	for(int i=0;i<grid.length;i++) {
		for(int j=0;j<grid[0].length;j++) {
			if(grid[i][j] == 1) {
				q.offer(new int[] {i,j});
				cnt++;
			}
		}
	}

	int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
	while(!q.isEmpty()) {
		int size = q.size();
		if(cnt == target)
			return hour;
		for(int i=0;i<size;i++) {
			int[] cur = q.poll();
			for(int[] dir : dirs) {
				int ni = cur[0] + dir[0];
				int nj = cur[1] + dir[1];
				if(ni < 0 || ni >= grid.length || nj < 0 || nj >= grid[0].length || grid[ni][nj] == 1) continue;
				grid[ni][nj] = 1;
				cnt++;
				
				q.offer(new int[] {ni, nj});
			}
		}
		hour++;
	}
	return -1;
}
 
 To those who keep getting 16, try for null, grid size 0, rows 0. Kept these and got 17/17. 
 Also easy cutting off if count of 1's = queue's size after first loop.
 
 if all matrix are person, return - 1
if no person in matrix, return 0;
if all person are infected but your BFS queue still > 0 , break;
 
 ------------------------------------------------------------------------------------------------------------------------
 763. Partition Labels
 class Solution {
    public List<Integer> partitionLabels(String S) {
        // last index map
        int [] lastIndexMap = new int[26];
        List<Integer> result = new ArrayList<>();
        for(int i = 0; i < S.length(); i ++){
            lastIndexMap[S.charAt(i) - 'a'] = i;
        }
        int right = 0;
        int left = 0;
        int lastIndex = 0;
        while(left < S.length()){
            // c 是将移入窗口的字符
            char c = S.charAt(left);
            lastIndex = lastIndexMap[c - 'a'];
            // 判断左侧窗口是否要收缩
            while(right < lastIndex){
                // d 是将移出窗口的字符
		        char d = S.charAt(right);
                lastIndex = Math.max(lastIndexMap[d - 'a'],lastIndex);
                right ++;
            }
            // right == lastIndex
            result.add(lastIndex - left + 1); // length 
            // left must be one plus lastIndex
            left = lastIndex + 1;
        }
        // time complexity is O(n)
        // space complexity is O(1)
        return result;
    }
}
 
1) The time complexity is O(N) and space complexity is O(n).
I created a array which stores the last index of the each unique character.

Then looping characters up to the current last index.
  When looping I keep asking, is current lastIndex is maximum. If we can guarantee
 Maximum index then this would be our partition end index.
There is only one pass looping through all characters. That’s why complexity is O(n).

Since no matter what input size is, there is only array size created for keeping tracking last index is 26.
Therefore the space complexity is O(1). 
However, we have returning List<Integer> which in worse case could end up O(n) time. 
Therefore, The time complexity is O(N) and space complexity is O(n).
 
 ------------------------------------------------------------------------------------------------------------------------
 937. Reorder Data in Log Files
 
 class Solution {
    public String[] reorderLogFiles(String[] logs) {
        Arrays.sort(logs, (s1, s2) -> {
            String[] split1 = s1.split(" ", 2);
            String[] split2 = s2.split(" ", 2);
			
		   // charAt misspell
            boolean isDigit1 = Character.isDigit(split1[1].charAt(0));
            boolean isDigit2 = Character.isDigit(split2[1].charAt(0));

            if(!isDigit1 && !isDigit2) {
                // both letter-logs. 
                int comp = split1[1].compareTo(split2[1]);
                if (comp == 0) return split1[0].compareTo(split2[0]);
                else return comp;
            } else if (isDigit1 && isDigit2) {
                // both digit-logs. So keep them in original order
                return 0; 
            } else if (isDigit1 && !isDigit2) {
                // first is digit, second is letter. bring letter to forward.
                return 1; // bring second argument to the front
            } else {
                //first is letter, second is digit. keep them in this order.
                return -1; // bring first argument to the front
            }
        });
        return logs;
    }
}
NOTE: Comparator:
 return -1 bring first parameter to the front
 return 1 bring second parameter to the front
 return 0 keep them in original order
 
 
 Overall complexity is O(nlogn). Since it require the sorting and worse case complexity is O(nlogn).
Space complexity is O(1), since it does not store any states in a collection or Data Structure on the execution of the program.
 
 
 ------------------------------------------------------------------------------------------------------------------------
200. Number of Clusters <=> Number of Islands(see DFS)
------------------------------------------------------------------------------------------------------------------------
1268. Search Suggestions System

Input: products = ["mobile","mouse","moneypot","monitor","mousepad"], searchWord = "mouse"
Output: [
["mobile","moneypot","monitor"],
["mobile","moneypot","monitor"],
["mouse","mousepad"],
["mouse","mousepad"],
["mouse","mousepad"]
]
Explanation: products sorted lexicographically = ["mobile","moneypot","monitor","mouse","mousepad"]
After typing m and mo all products match and we show user ["mobile","moneypot","monitor"]
After typing mou, mous and mouse the system suggests ["mouse","mousepad"]

class Solution {
    class Trie {
        Trie[] sub = new Trie[26];
        LinkedList<String> suggestion = new LinkedList<>();
    }
    public List<List<String>> suggestedProducts(String[] products, String searchWord) {
        Arrays.sort(products); // sort products.
        Trie root = new Trie();
        for (String p : products) { // build Trie.
            Trie t = root;
            for (char c : p.toCharArray()) { // insert current product into Trie.
                if (t.sub[c - 'a'] == null)
                    t.sub[c - 'a'] = new Trie();
                t = t.sub[c - 'a'];
                if (t.suggestion.size() < 3) // maintain 3 lexicographically minimum strings.
                    t.suggestion.offer(p); // put products with same prefix into suggestion list.
            }
        }
        List<List<String>> ans = new ArrayList<>();
        for (char c : searchWord.toCharArray()) { // search product.
            if (root != null) // if there exist products with current prefix.
                root = root.sub[c - 'a'];
            ans.add(root == null ? Arrays.asList() : root.suggestion); // add it if there exist products with current prefix.
        }
        return ans;
    }

}

Complexity depends on the sorting, the process of building Trie and the length of searchWord. Sorting cost time O(m * n * logn), due to involving comparing String, which cost time O(m) for each comparison, building Trie cost O(m * n). Therefore,
Time: O(m * n * logn + L), space: O(m * n + L * m) - including return list ans, where m = average length of products, n = products.length, L = searchWord.length().

------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
 
1192. Critical Connections in a Network

------------------
994. Rotting Oranges

class Solution {
    public int orangesRotting(int[][] grid) {
        if(grid.length == 0 || grid[0].length == 0) return -1;
        int fresh = 0;
        Queue<int[]> queue = new LinkedList<>();
        for(int i = 0; i < grid.length; i++){
            for(int j = 0; j < grid[0].length;j++){
                if(grid[i][j] == 1) fresh++;
                if(grid[i][j] == 2) queue.add(new int[]{i,j});
            }
        }
        if(fresh == 0) return 0;
        
        int mins = 0;
        
        int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};
        while(!queue.isEmpty()){
            int size = queue.size();
             if(fresh == 0) return mins; // goal
            for(int k = 0; k < size; k++){
                int[] cur = queue.poll();
                for(int[] dir: dirs){
                    int x = cur[0] + dir[0];
                    int y = cur[1] + dir[1];
                    if(x < 0 || x == grid.length || y < 0 || y == grid[0].length || grid[x][y] != 1) continue;
                    grid[x][y] = 2;// want 1 -> 2 so grid[x][y] != 1
                    queue.add(new int[] {x,y});
                    fresh --;
                }
            }
            mins ++;
        }
        
        return -1;
        
    }
}

Time Complexity: M*N where m is row size of grid n is column size of grid


------------------------------------------------------------------------------------------------------------------------
Two Sum - Unique Pairs
Input: nums = [1, 1, 2, 45, 46, 46], target = 47
Output: 2
Explanation:
1 + 46 = 47
2 + 45 = 47


public static int uniquePairs(int[] nums, int target){
	Set<Integer> set = new HashSet<Integer>();
	Set<Integer> seen = new HashSet<Integer>();
	int count = 0;
	for(int num : nums){
	    if(set.contains(target-num) && !seen.contains(num)){
		count++;
		seen.add(target-num);
		seen.add(num);
	    }
	    else if(!set.contains(num)){
		set.add(num);
	    }
	}
	return count;
}


------------------------------------------------------------------------------------------------------------------------
Optimal Utilization

https://leetcode.com/discuss/interview-question/373202

Given 2 lists a and b. Each element is a pair of integers where the first integer represents the unique id and the second integer represents a value. Your task is to find an element from a and an element form b such that the sum of their values is less or equal to target and as close to target as possible. Return a list of ids of selected elements. If no pair is possible, return an empty list.

Example 1:

Input:
a = [[1, 2], [2, 4], [3, 6]]
b = [[1, 2]]
target = 7

Output: [[2, 1]]

Explanation:
There are only three combinations [1, 1], [2, 1], and [3, 1], which have a total sum of 4, 6 and 8, respectively.
Since 6 is the largest sum that does not exceed 7, [2, 1] is the optimal pair.

 private List<int[]> getPairs(List<int[]> a, List<int[]> b, int target) {
	Collections.sort(a, (i,j) -> i[1] - j[1]);
	Collections.sort(b, (i,j) -> i[1] - j[1]);
	List<int[]> result = new ArrayList<>();
	int max = Integer.MIN_VALUE;
	int m = a.size();
	int n = b.size();
	int i =0;
	int j =n-1;
	while(i<m && j >= 0) {
		int sum = a.get(i)[1] + b.get(j)[1];
		if(sum > target) {
			 --j;
		} else {
			if(max <= sum) {
				if(max < sum) {
					max = sum;
					result.clear();
				}
				result.add(new int[]{a.get(i)[0], b.get(j)[0]});
				int index = j-1;
				while(index >=0 && b.get(index)[1] == b.get(index+1)[1]) {
					 result.add(new int[]{a.get(i)[0], b.get(index--)[0]});
				}
			}
			++i;
		}
	}
	return result;
} 

-------------------------------------------------------------------------------------------------------------------------
Min Cost to Connect Ropes / Min Time to Merge Files [Experienced]

Given n ropes of different lengths, we need to connect these ropes into one rope. We can connect only 2 ropes at a time. The cost required to connect 2 ropes is equal to sum of their lengths. The length of this connected rope is also equal to the sum of their lengths. This process is repeated until n ropes are connected into a single rope. Find the min possible cost required to connect all ropes.

Example 1:

Input: ropes = [8, 4, 6, 12]
Output: 58
Explanation: The optimal way to connect ropes is as follows
1. Connect the ropes of length 4 and 6 (cost is 10). Ropes after connecting: [8, 10, 12]
2. Connect the ropes of length 8 and 10 (cost is 18). Ropes after connecting: [18, 12]
3. Connect the ropes of length 18 and 12 (cost is 30).
Total cost to connect the ropes is 10 + 18 + 30 = 58


public static void main(String[] args) {
	int[] files1 = {8, 4, 6, 12};
	int[] files2 = {20, 4, 8, 2};
	int[] files3 = {1, 2, 5, 10, 35, 89};
	int[] files4 = {2, 2, 3, 3};
	System.out.println(mergeFiles(files1));
	System.out.println(mergeFiles(files2));
	System.out.println(mergeFiles(files3));
	System.out.println(mergeFiles(files4));
}

private static int mergeFiles(int[] files) {
	Queue<Integer> minHeap = new PriorityQueue<Integer>();
	for(int f : files) {
		minHeap.offer(f);
	}
	int res = 0;
	while(minHeap.size() > 1) {
		int f1 = minHeap.poll();
		int f2 = minHeap.poll();
		int tmp = f1 + f2;
		res += tmp;
		minHeap.offer(tmp);
	}
	return res;
}



------------------------------------------------------------------------------------------------------------------------------



all Questions
https://leetcode.com/discuss/interview-question/344650/Amazon-Online-Assessment-Questions
