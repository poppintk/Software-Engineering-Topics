Given an undirected graph with n nodes labeled 1..n. Some of the nodes are already connected. The i-th edge connects nodes edges[i][0] and edges[i][1] together. Your task is to augment this set of edges with additional edges to connect all the nodes. Find the minimum cost to add new edges between the nodes such that all the nodes are accessible from each other.

Input:

n, an int representing the total number of nodes.
edges, a list of integer pair representing the nodes already connected by an edge.
newEdges, a list where each element is a triplet representing the pair of nodes between which an edge can be added and the cost of addition, respectively (e.g. [1, 2, 5] means to add an edge between node 1 and 2, the cost would be 5).
Example 1:

Input: n = 6, edges = [[1, 4], [4, 5], [2, 3]], newEdges = [[1, 2, 5], [1, 3, 10], [1, 6, 2], [5, 6, 5]]
Output: 7
Explanation:
There are 3 connected components [1, 4, 5], [2, 3] and [6].
We can connect these components into a single component by connecting node 1 to node 2 and node 1 to node 6 at a minimum cost of 5 + 2 = 7.

// https://leetcode.com/discuss/interview-question/356981

public class Main {
    public static void main(String[] args) {
        int n = 6;
        int[][] edges = {{1, 4}, {4, 5}, {2, 3}};
        int[][] newEdges = {{1, 2, 5}, {1, 3, 10}, {1, 6, 2}, {5, 6, 5}};
        System.out.println(minCost(n, edges, newEdges));
    }
    
    public static int minCost(int n, int[][] edges, int[][] newEdges) {
        UF uf = new UF(n + 1); // + 1 because nodes are 1-based
        for (int[] edge : edges) {
            uf.union(edge[0], edge[1]);
        }
        
        Queue<int[]> pq = new PriorityQueue<>(newEdges.length, (e1, e2) -> Integer.compare(e1[2], e2[2]));
        pq.addAll(Arrays.asList(newEdges));
        
        int totalCost = 0;
        // 2 because nodes are 1-based and we have 1 unused component at index 0
        while (!pq.isEmpty() && uf.count != 2) {
            int[] edge = pq.poll();
            if (!uf.connected(edge[0], edge[1])) {
                uf.union(edge[0], edge[1]);
                totalCost += edge[2];
            }
        }
        return totalCost;
    }
}

class UF {
    private int[] parent;  // parent[i] = parent of i
    private byte[] rank;   // rank[i] = rank of subtree rooted at i (never more than 31)
    public int count;      // number of connected components

    public UF(int n) {
        if (n < 0) throw new IllegalArgumentException();
        parent = new int[n];
        rank = new byte[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
        count = n;
    }

    public int find(int p) {
        while (p != parent[p]) {
            parent[p] = parent[parent[p]];
            p = parent[p];
        }
        return p;
    }

    public void union(int p, int q) {
        int pr = find(p);
        int qr = find(q);
        if (pr == qr) return;
        if (rank[pr] < rank[qr]) {
            parent[pr] = qr;
        } else {
            parent[qr] = pr;
            if (rank[pr] == rank[qr]) rank[pr]++;
        }
        count--;
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }
}

------------------------------------------------------------------------------------------------------------------------
 Zombie in Matrix
 
 Given a 2D grid, each cell is either a zombie 1 or a human 0. Zombies can turn adjacent (up/down/left/right) human beings into zombies every hour. Find out how many hours does it take to infect all humans?

Example:

Input:
[[0, 1, 1, 0, 1],
 [0, 1, 0, 1, 0],
 [0, 0, 0, 0, 1],
 [0, 1, 0, 0, 0]]

Output: 2

Explanation:
At the end of the 1st hour, the status of the grid:
[[1, 1, 1, 1, 1],
 [1, 1, 1, 1, 1],
 [0, 1, 0, 1, 1],
 [1, 1, 1, 0, 1]]

At the end of the 2nd hour, the status of the grid:
[[1, 1, 1, 1, 1],
 [1, 1, 1, 1, 1],
 [1, 1, 1, 1, 1],
 [1, 1, 1, 1, 1]]
int minHours(int rows, int columns, List<List<Integer>> grid) {
	// todo
}

public static void main(String[] args) {
	int[][] grid = { { 0, 1, 1, 0, 1 }, { 0, 1, 0, 1, 0 }, { 0, 0, 0, 0, 1 }, { 0, 1, 0, 0, 0 } };
	System.out.println(minDays(grid));
}

private static int minDays(int[][] grid) {
	Queue<int[]> q = new LinkedList<>();
	int target = grid.length * grid[0].length;
	int cnt = 0, res = 0;
	for(int i=0;i<grid.length;i++) {
		for(int j=0;j<grid[0].length;j++) {
			if(grid[i][j] == 1) {
				q.offer(new int[] {i,j});
				cnt++;
			}
		}
	}
	int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
	while(!q.isEmpty()) {
		int size = q.size();
		if(cnt == target)
			return res;
		for(int i=0;i<size;i++) {
			int[] cur = q.poll();
			for(int[] dir : dirs) {
				int ni = cur[0] + dir[0];
				int nj = cur[1] + dir[1];
				if(ni >=0 && ni < grid.length && nj >=0 && nj < grid[0].length && grid[ni][nj] == 0) {
					cnt++;
					q.offer(new int[] {ni, nj});
					grid[ni][nj] = 1;
				}
			}
		}
		res++;
	}
	return -1;
}
 
 To those who keep getting 16, try for null, grid size 0, rows 0. Kept these and got 17/17. 
 Also easy cutting off if count of 1's = queue's size after first loop.
 
 if all matrix are person, return - 1
if no person in matrix, return 0;
if all person are infected but your BFS queue still > 0 , break;
 
 ------------------------------------------------------------------------------------------------------------------------
 763. Partition Labels
 class Solution {
    
    public List<Integer> partitionLabels(String S) {
        // last index map
        int [] lastIndexMap = new int[26];
        List<Integer> result = new ArrayList<>();
        for(int i = 0; i < S.length(); i ++){
            lastIndexMap[S.charAt(i) - 'a'] = i;
        }
        int start = 0;
        int end = 0;
        int lastIndex = 0;
        while(end < S.length()){
            lastIndex = lastIndexMap[S.charAt(end) - 'a'];
            while(start < lastIndex){
                lastIndex = Math.max(lastIndexMap[S.charAt(start) - 'a'],lastIndex);
                start ++;
            }
            // start == lastIndex
            result.add(lastIndex - end + 1);
            // end must be one plus lastIndex
            end = lastIndex + 1;
        }
        // time complexity is O(n)
        // space complexity is O(1)
        return result;
    }
}
 
1) The time complexity is O(N) and space complexity is O(n).
I created a array which stores the last index of the each unique character.

Then looping characters up to the current last index.
  When looping I keep asking, is current lastIndex is maximum. If we can guarantee
 Maximum index then this would be our partition end index.
There is only one pass looping through all characters. Thatâ€™s why complexity is O(n).

Since no matter what input size is, there is only array size created for keeping tracking last index is 26.
Therefore the space complexity is O(1). 
However, we have returning List<Integer> which in worse case could end up O(n) time. 
Therefore, The time complexity is O(N) and space complexity is O(n).
 
 ------------------------------------------------------------------------------------------------------------------------
 937. Reorder Data in Log Files
 
 class Solution {
    public String[] reorderLogFiles(String[] logs) {
        Arrays.sort(logs, (s1, s2) -> {
            String[] split1 = s1.split(" ", 2);
            String[] split2 = s2.split(" ", 2);
			
		   // charAt misspell
            boolean isDigit1 = Character.isDigit(split1[1].charAt(0));
            boolean isDigit2 = Character.isDigit(split2[1].charAt(0));

            if(!isDigit1 && !isDigit2) {
                // both letter-logs. 
                int comp = split1[1].compareTo(split2[1]);
                if (comp == 0) return split1[0].compareTo(split2[0]);
                else return comp;
            } else if (isDigit1 && isDigit2) {
                // both digit-logs. So keep them in original order
                return 0; 
            } else if (isDigit1 && !isDigit2) {
                // first is digit, second is letter. bring letter to forward.
                return 1; // bring second argument to the front
            } else {
                //first is letter, second is digit. keep them in this order.
                return -1; // bring first argument to the front
            }
        });
        return logs;
    }
}
NOTE: Comparator:
 return -1 bring first parameter to the front
 return 1 bring second parameter to the front
 return 0 keep them in original order
 
 
 Overall complexity is O(nlogn). Since it require the sorting and worse case complexity is O(nlogn).
Space complexity is O(1), since it does not store any states in a collection or Data Structure on the execution of the program.
 
 
 ------------------------------------------------------------------------------------------------------------------------
200. Number of Clusters <=> Number of Islands(see DFS)
------------------------------------------------------------------------------------------------------------------------
1268. Search Suggestions System

class Solution {
    class Trie {
        Trie[] sub = new Trie[26];
        LinkedList<String> suggestion = new LinkedList<>();
    }
    public List<List<String>> suggestedProducts(String[] products, String searchWord) {
        Arrays.sort(products); // sort products.
        Trie root = new Trie();
        for (String p : products) { // build Trie.
            Trie t = root;
            for (char c : p.toCharArray()) { // insert current product into Trie.
                if (t.sub[c - 'a'] == null)
                    t.sub[c - 'a'] = new Trie();
                t = t.sub[c - 'a'];
                if (t.suggestion.size() < 3) // maintain 3 lexicographically minimum strings.
                    t.suggestion.offer(p); // put products with same prefix into suggestion list.
            }
        }
        List<List<String>> ans = new ArrayList<>();
        for (char c : searchWord.toCharArray()) { // search product.
            if (root != null) // if there exist products with current prefix.
                root = root.sub[c - 'a'];
            ans.add(root == null ? Arrays.asList() : root.suggestion); // add it if there exist products with current prefix.
        }
        return ans;
    }

}

Complexity depends on the sorting, the process of building Trie and the length of searchWord. Sorting cost time O(m * n * logn), due to involving comparing String, which cost time O(m) for each comparison, building Trie cost O(m * n). Therefore,
Time: O(m * n * logn + L), space: O(m * n + L * m) - including return list ans, where m = average length of products, n = products.length, L = searchWord.length().

------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
 
1192. Critical Connections in a Network

------------------
994. Rotting Oranges

------------------

all Questions
https://leetcode.com/discuss/interview-question/344650/Amazon-Online-Assessment-Questions
