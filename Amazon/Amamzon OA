Top K Frequently Mentioned Keywords

Given a list of reviews, a list of keywords and an integer k. Find the most popular k keywords in order of most to least frequently mentioned.
The comparison of strings is case-insensitive. If keywords are mentioned an equal number of times in reviews, sort alphabetically.

Example 1:

Input:
k = 2
keywords = ["anacell", "cetracular", "betacellular"]
reviews = [
  "Anacell provides the best services in the city",
  "betacellular has awesome services",
  "Best services provided by anacell, everyone should use anacell",
]

Output:
["anacell", "betacellular"]

Explanation:
"anacell" is occuring in 2 different reviews and "betacellular" is only occuring in 1 review.


public List<String> solve(int k, String[] keywords, String[] reviews) {
	Map<String, Integer> hm = new HashMap<>();
	for (String sentence : reviews) {
		Set<String> hs = new HashSet<>(); // Note: hashSet is used here due to in a sentence there could be more than one occurrence of word
		String[] words = sentence.split("\\W");
		for (String word : words) {
			hs.add(word.toLowerCase());
		}
		for(String word : hs){
			word = word.toLowerCase();
			hm.put(word, hm.getOrDefault(word, 0) + 1);
		}
	}
	PriorityQueue<String> pq = new PriorityQueue<>((a, b) -> hm.get(a) != hm.get(b) ? hm.get(a) - hm.get(b) : b.compareTo(a));
	for (String str : keywords) {
		str = str.toLowerCase();
		if (hm.containsKey(str)) { // keyword might not exist in reviews
			pq.offer(str); // offer() or add()
		}//if word is not in reviews need to sort alphabetically?
		if (pq.size() > k) {
			pq.poll();
		}
	}
	List<String> res = new ArrayList<>();
	while (!pq.isEmpty()) {
		res.add(pq.poll());
	}
	Collections.reverse(res);
	return res;
}
O(M*N + Llog(k+1)
---------------------------------------------------------------------------------------------------------------------------
Min Cost to Connect All Nodes/ Min Cost to Repair Edges/ Min Cost to Add New Roads
!!!!!!!!!!!!!
NOTE:The only difference is, watch out if edges is already excluding from newEdges or brokenEdge
if not, we need filter out from edges list

Set<String> broken = new HashSet<>();

for(int[] edge: edgesToRepair){
    broken.add(String.valueOf(edge[0]) + String.valueOf(edge[1]));
    broken.add(String.valueOf(edge[1]) + String.valueOf(edge[0]));
}

for (int[] edge : edges) {
    if(broken.contains(String.valueOf(edge[1]) + String.valueOf(edge[0]))) continue;
    if(broken.contains(String.valueOf(edge[0]) + String.valueOf(edge[1]))) continue;
    uf.union(edge[0], edge[1]); // union should excluding those edge that broken.
}

Given an undirected graph with n nodes labeled 1..n. Some of the nodes are already connected. The i-th edge connects nodes edges[i][0] and edges[i][1] together. Your task is to augment this set of edges with additional edges to connect all the nodes. Find the minimum cost to add new edges between the nodes such that all the nodes are accessible from each other.

Input:

n, an int representing the total number of nodes.
edges, a list of integer pair representing the nodes already connected by an edge.
newEdges, a list where each element is a triplet representing the pair of nodes between which an edge can be added and the cost of addition, respectively (e.g. [1, 2, 5] means to add an edge between node 1 and 2, the cost would be 5).
Example 1:

Input: n = 6, edges = [[1, 4], [4, 5], [2, 3]], newEdges = [[1, 2, 5], [1, 3, 10], [1, 6, 2], [5, 6, 5]]

Output: 7

Explanation:
There are 3 connected components [1, 4, 5], [2, 3] and [6].
We can connect these components into a single component by connecting node 1 to node 2 and node 1 to node 6 at a minimum cost of 5 + 2 = 7.

// https://leetcode.com/discuss/interview-question/356981
Kruskal Algorithm
public class Main {
    public static void main(String[] args) {
        int n = 6;
        int[][] edges = {{1, 4}, {4, 5}, {2, 3}};
        int[][] newEdges = {{1, 2, 5}, {1, 3, 10}, {1, 6, 2}, {5, 6, 5}};
        System.out.println(minCost(n, edges, newEdges));
    }
    
    public static int minCost(int n, int[][] edges, int[][] newEdges) {
        UF uf = new UF(n + 1); // + 1 because nodes are 1-based
        for (int[] edge : edges) {
            uf.union(edge[0], edge[1]);
        }
        
        Queue<int[]> pq = new PriorityQueue<>(newEdges.length, (e1, e2) -> Integer.compare(e1[2], e2[2]));
        pq.addAll(Arrays.asList(newEdges)); // Note: syntax sugar
        
        int totalCost = 0;
        // 2 because nodes are 1-based and we have 1 unused component at index 0
        while (!pq.isEmpty() && uf.count != 2) {
            int[] edge = pq.poll();
            if (!uf.connected(edge[0], edge[1])) {
                uf.union(edge[0], edge[1]);
                totalCost += edge[2];
            }
        }
        return totalCost;
    }
}

class UF {
    private int[] parent;  // parent[i] = parent of i
    private byte[] rank;   // rank[i] = rank of subtree rooted at i (never more than 31)
    public int count;      // number of connected components

    public UF(int n) {
        if (n < 0) throw new IllegalArgumentException();
        parent = new int[n];
        rank = new byte[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
        }
        count = n;
    }

    public int find(int p) {
        while (p != parent[p]) {
            parent[p] = parent[parent[p]];
            p = parent[p];
        }
        return p;
    }

    public void union(int p, int q) {
        int pr = find(p);
        int qr = find(q);
        if (pr == qr) return;
        if (rank[pr] < rank[qr]) {
            parent[pr] = qr;
        } else {
            parent[qr] = pr;
            if (rank[pr] == rank[qr]) rank[pr]++;
        }
        count--;
    }

    public boolean connected(int p, int q) {
        return find(p) == find(q);
    }
}
O(Elogv)
------------------------------------------------------------------------------------------------------------------------
 Zombie in Matrix
 
 Given a 2D grid, each cell is either a zombie 1 or a human 0. Zombies can turn adjacent (up/down/left/right) human beings into zombies every hour. Find out how many hours does it take to infect all humans?

Example:

Input:
[[0, 1, 1, 0, 1],
 [0, 1, 0, 1, 0],
 [0, 0, 0, 0, 1],
 [0, 1, 0, 0, 0]]

Output: 2

Explanation:
At the end of the 1st hour, the status of the grid:
[[1, 1, 1, 1, 1],
 [1, 1, 1, 1, 1],
 [0, 1, 0, 1, 1],
 [1, 1, 1, 0, 1]]

At the end of the 2nd hour, the status of the grid:
[[1, 1, 1, 1, 1],
 [1, 1, 1, 1, 1],
 [1, 1, 1, 1, 1],
 [1, 1, 1, 1, 1]]
int minHours(int rows, int columns, List<List<Integer>> grid) {
	// todo
}

public static void main(String[] args) {
	//int[][] grid = { { 0,1,0,0}, { 0, 0, 0, 0}, { 0, 0, 0, 0 }, { 0,0, 0, 0 } };
	int[][] grid = { { 0, 1, 1, 0, 1 }, { 0, 1, 0, 1, 0 }, { 0, 0, 0, 0, 1 }, { 0, 1, 0, 0, 0 } };
    System.out.println(minDays(grid));
}

private static int minDays(int[][] grid) {
	if(grid.length == 0 || grid[0].length == 0) return -1;

	Queue<int[]> q = new LinkedList<>();
	int target = grid.length * grid[0].length;
	int cnt = 0, hour = 0;
	for(int i=0;i<grid.length;i++) {
		for(int j=0;j<grid[0].length;j++) {
			if(grid[i][j] == 1) {
				q.offer(new int[] {i,j});
				cnt++;
			}
		}
	}

	int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
	while(!q.isEmpty()) {
		int size = q.size();
		if(cnt == target)
			return hour;
		for(int i=0;i<size;i++) {
			int[] cur = q.poll();
			for(int[] dir : dirs) {
				int ni = cur[0] + dir[0];
				int nj = cur[1] + dir[1];
				if(ni < 0 || ni >= grid.length || nj < 0 || nj >= grid[0].length || grid[ni][nj] == 1) continue;
				grid[ni][nj] = 1;
				cnt++;
				
				q.offer(new int[] {ni, nj});
			}
		}
		hour++;
	}
	return -1;
}
 
 To those who keep getting 16, try for null, grid size 0, rows 0. Kept these and got 17/17. 
 Also easy cutting off if count of 1's = queue's size after first loop.
 
 if all matrix are person, return - 1
if no person in matrix, return 0;
if all person are infected but your BFS queue still > 0 , break;
 O(m*n)
 ------------------------------------------------------------------------------------------------------------------------
 763. Partition Labels
 class Solution {
    public List<Integer> partitionLabels(String S) {
        // last index map
        int [] lastIndexMap = new int[26];
        List<Integer> result = new ArrayList<>();
        for(int i = 0; i < S.length(); i ++){
            lastIndexMap[S.charAt(i) - 'a'] = i;
        }
        int right = 0;
        int left = 0;
        int lastIndex = 0;
        while(left < S.length()){
            // c 是将移入窗口的字符
            char c = S.charAt(left);
            lastIndex = lastIndexMap[c - 'a'];
            // 判断左侧窗口是否要收缩
            while(right < lastIndex){
                // d 是将移出窗口的字符
		        char d = S.charAt(right);
                lastIndex = Math.max(lastIndexMap[d - 'a'],lastIndex);
                right ++;
            }
            // right == lastIndex
            result.add(lastIndex - left + 1); // length 
            // left must be one plus lastIndex
            left = lastIndex + 1;
        }
        // time complexity is O(n)
        // space complexity is O(1)
        return result;
    }
}
 
1) The time complexity is O(N) and space complexity is O(n).
I created a array which stores the last index of the each unique character.

Then looping characters up to the current last index.
  When looping I keep asking, is current lastIndex is maximum. If we can guarantee
 Maximum index then this would be our partition end index.
There is only one pass looping through all characters. That’s why complexity is O(n).

Since no matter what input size is, there is only array size created for keeping tracking last index is 26.
Therefore the space complexity is O(1). 
However, we have returning List<Integer> which in worse case could end up O(n) time. 
Therefore, The time complexity is O(N) and space complexity is O(n).
 
 ------------------------------------------------------------------------------------------------------------------------
 937. Reorder Data in Log Files
 
 class Solution {
    public String[] reorderLogFiles(String[] logs) {
        Arrays.sort(logs, (s1, s2) -> {
            String[] split1 = s1.split(" ", 2);
            String[] split2 = s2.split(" ", 2);
			
		   // charAt misspell
            boolean isDigit1 = Character.isDigit(split1[1].charAt(0));
            boolean isDigit2 = Character.isDigit(split2[1].charAt(0));

            if(!isDigit1 && !isDigit2) {
                // both letter-logs. 
                int comp = split1[1].compareTo(split2[1]);
                if (comp == 0) return split1[0].compareTo(split2[0]);
                else return comp;
            } else if (isDigit1 && isDigit2) {
                // both digit-logs. So keep them in original order
                return 0; 
            } else if (isDigit1 && !isDigit2) {
                // first is digit, second is letter. bring letter to forward.
                return 1; // bring second argument to the front
            } else {
                //first is letter, second is digit. keep them in this order.
                return -1; // bring first argument to the front
            }
        });
        return logs;
    }
}
NOTE: Comparator:
 return -1 bring first parameter to the front
 return 1 bring second parameter to the front
 return 0 keep them in original order
 
 
 Overall complexity is O(lnlogn) where l is length of String. Since it require the sorting and worse case complexity is O(nlogn).
Space complexity is O(1), since it does not store any states in a collection or Data Structure on the execution of the program.
 
 
 ------------------------------------------------------------------------------------------------------------------------
200. Number of Clusters <=> Number of Islands(see DFS)
------------------------------------------------------------------------------------------------------------------------
1268. Search Suggestions System

Input: products = ["mobile","mouse","moneypot","monitor","mousepad"], searchWord = "mouse"
Output: [
["mobile","moneypot","monitor"],
["mobile","moneypot","monitor"],
["mouse","mousepad"],
["mouse","mousepad"],
["mouse","mousepad"]
]
Explanation: products sorted lexicographically = ["mobile","moneypot","monitor","mouse","mousepad"]
After typing m and mo all products match and we show user ["mobile","moneypot","monitor"]
After typing mou, mous and mouse the system suggests ["mouse","mousepad"]

class Solution {
    class Trie {
        Trie[] sub = new Trie[26];
        LinkedList<String> suggestion = new LinkedList<>();
    }
    public List<List<String>> suggestedProducts(String[] products, String searchWord) {
        Arrays.sort(products); // sort products.
        Trie root = new Trie();
        for (String p : products) { // build Trie.
            Trie t = root;
            for (char c : p.toCharArray()) { // insert current product into Trie.
                if (t.sub[c - 'a'] == null)
                    t.sub[c - 'a'] = new Trie();
                t = t.sub[c - 'a'];
                if (t.suggestion.size() < 3) // maintain 3 lexicographically minimum strings.
                    t.suggestion.offer(p); // put products with same prefix into suggestion list.
            }
        }
        List<List<String>> ans = new ArrayList<>();
        for (char c : searchWord.toCharArray()) { // search product.
            if (root != null) // if there exist products with current prefix.
                root = root.sub[c - 'a'];
            ans.add(root == null ? Arrays.asList() : root.suggestion); // add it if there exist products with current prefix.
        }
        return ans;
    }

}

Complexity depends on the sorting, the process of building Trie and the length of searchWord. Sorting cost time O(m * n * logn), due to involving comparing String, which cost time O(m) for each comparison, building Trie cost O(m * n). Therefore,
Time: O(m * n * logn + L), space: O(m * n + L * m) - including return list ans, where m = average length of products, n = products.length, L = searchWord.length().

------------------------------------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------------------------------------
 
1192. Critical Connections in a Network

------------------
994. Rotting Oranges

class Solution {
    public int orangesRotting(int[][] grid) {
        if(grid.length == 0 || grid[0].length == 0) return -1;
        int fresh = 0;
        Queue<int[]> queue = new LinkedList<>();
        for(int i = 0; i < grid.length; i++){
            for(int j = 0; j < grid[0].length;j++){
                if(grid[i][j] == 1) fresh++;
                if(grid[i][j] == 2) queue.add(new int[]{i,j});
            }
        }
        if(fresh == 0) return 0;
        
        int mins = 0;
        
        int[][] dirs = new int[][]{{1,0},{-1,0},{0,1},{0,-1}};
        while(!queue.isEmpty()){
            int size = queue.size();
             if(fresh == 0) return mins; // goal
            for(int k = 0; k < size; k++){
                int[] cur = queue.poll();
                for(int[] dir: dirs){
                    int x = cur[0] + dir[0];
                    int y = cur[1] + dir[1];
                    if(x < 0 || x == grid.length || y < 0 || y == grid[0].length || grid[x][y] != 1) continue;
                    grid[x][y] = 2;// want 1 -> 2 so grid[x][y] != 1
                    queue.add(new int[] {x,y});
                    fresh --;
                }
            }
            mins ++;
        }
        
        return -1;
        
    }
}

Time Complexity: M*N where m is row size of grid n is column size of grid
----------------------------------------------------------------------------------------------------------------------------
Find Pair With Given Sum

The differences between Find Pair With Given Sum and Movies on Flight are:

Find Pair With Given Sum asks us to find exactly the target, that's why using a map in Find Pair With Given Sum is a good idea. While Movies on Flight asks us to find value closest to target.
Find Pair With Given Sum gives valid input, while in Movies on Flight you need to handle input with no answer.
Therefore I have developed two diffe


Given a list of positive integers nums and an int target, return indices of the two numbers such that they add up to a target - 30.

Conditions:

You will pick exactly 2 numbers.
You cannot pick the same element twice.
If you have muliple pairs, select the pair with the largest number.
Example 1:

Input: nums = [1, 10, 25, 35, 60], target = 90
Output: [2, 3]
Explanation:
nums[2] + nums[3] = 25 + 35 = 60 = 90 - 30
Example 2:

Input: nums = [20, 50, 40, 25, 30, 10], target = 90
Output: [1, 5]
Explanation:
nums[0] + nums[2] = 20 + 40 = 60 = 90 - 30
nums[1] + nums[5] = 50 + 10 = 60 = 90 - 30
You should return the pair with the largest number.


public static void main(String[] args) {
	int[] nums1 = {1, 10, 25, 35, 60};
	int target1 = 90;
	System.out.println(Arrays.toString(Find2Sum(nums1, target1-30)));
	int[] nums2 = {20, 50, 40, 25, 30, 10};
	int target2 = 90;
	System.out.println(Arrays.toString(Find2Sum(nums2, target2-30)));
	int[] nums3 = {50, 20, 10, 40, 25, 30};
	int target3 = 90;
	System.out.println(Arrays.toString(Find2Sum(nums3, target3-30)));
	int[] nums4 = {1, 2};
	int target4 = 90;
	System.out.println(Arrays.toString(Find2Sum(nums4, target4-30)));
}

private static int[] Find2Sum(int[] nums, int target) {
	Map<Integer, Integer> map = new HashMap<>();
	int max = Integer.MIN_VALUE;
	int[] res = new int[] {-1, -1};
	for(int i=0;i<nums.length;i++) {
		if(map.containsKey(nums[i])) {
			if(nums[i] > max || nums[map.get(nums[i])] > max) {
				res[0] = map.get(nums[i]);
				res[1] = i;
				max = Math.max(nums[i], nums[map.get(nums[i])]);
			}
		}
		map.put(target - nums[i], i);
	}
	return res;
}


Return null or empty list. You can test it out.
Consider when there is no such a pair, return null or empty list. Again, one of them is correct~
Consider a test case like [0, 0] and target = 30. Do you think it is a valid pair? YES!
I had been trying for 30 mins this morning. Please upvote. THX!~

------------------------------------------------------------------------------------------------------------------------
Two Sum - Unique Pairs
Input: nums = [1, 1, 2, 45, 46, 46], target = 47
Output: 2
Explanation:
1 + 46 = 47
2 + 45 = 47


public static int uniquePairs(int[] nums, int target){
	Set<Integer> set = new HashSet<Integer>();
	Set<Integer> seen = new HashSet<Integer>();
	int count = 0;
	for(int num : nums){
	    if(set.contains(target-num) && !seen.contains(num)){
		count++;
		seen.add(target-num);
		seen.add(num);
	    }
	    else if(!set.contains(num)){
		set.add(num);
	    }
	}
	return count;
}


------------------------------------------------------------------------------------------------------------------------
Optimal Utilization

https://leetcode.com/discuss/interview-question/373202

Given 2 lists a and b. Each element is a pair of integers where the first integer represents the unique id and the second integer represents a value. Your task is to find an element from a and an element form b such that the sum of their values is less or equal to target and as close to target as possible. Return a list of ids of selected elements. If no pair is possible, return an empty list.

Example 1:

Input:
a = [[1, 2], [2, 4], [3, 6]]
b = [[1, 2]]
target = 7

Output: [[2, 1]]

Explanation:
There are only three combinations [1, 1], [2, 1], and [3, 1], which have a total sum of 4, 6 and 8, respectively.
Since 6 is the largest sum that does not exceed 7, [2, 1] is the optimal pair.

 private List<int[]> getPairs(List<int[]> a, List<int[]> b, int target) {
	Collections.sort(a, (i,j) -> i[1] - j[1]);
	Collections.sort(b, (i,j) -> i[1] - j[1]);
	List<int[]> result = new ArrayList<>();
	int max = Integer.MIN_VALUE;
	int m = a.size();
	int n = b.size();
	int i =0;
	int j =n-1;
	while(i<m && j >= 0) {
		int sum = a.get(i)[1] + b.get(j)[1];
		if(sum > target) {
			 --j;
		} else {
			if(max <= sum) {
				if(max < sum) {
					max = sum;
					result.clear();
				}
				result.add(new int[]{a.get(i)[0], b.get(j)[0]});
				int index = j-1;
				while(index >=0 && b.get(index)[1] == b.get(index+1)[1]) {
					 result.add(new int[]{a.get(i)[0], b.get(index--)[0]});
				}
			}
			++i;
		}
	}
	return result;
} 

-------------------------------------------------------------------------------------------------------------------------
Min Cost to Connect Ropes / Min Time to Merge Files [Experienced]

Given n ropes of different lengths, we need to connect these ropes into one rope. We can connect only 2 ropes at a time. The cost required to connect 2 ropes is equal to sum of their lengths. The length of this connected rope is also equal to the sum of their lengths. This process is repeated until n ropes are connected into a single rope. Find the min possible cost required to connect all ropes.

Example 1:

Input: ropes = [8, 4, 6, 12]
Output: 58
Explanation: The optimal way to connect ropes is as follows
1. Connect the ropes of length 4 and 6 (cost is 10). Ropes after connecting: [8, 10, 12]
2. Connect the ropes of length 8 and 10 (cost is 18). Ropes after connecting: [18, 12]
3. Connect the ropes of length 18 and 12 (cost is 30).
Total cost to connect the ropes is 10 + 18 + 30 = 58


public static void main(String[] args) {
	int[] files1 = {8, 4, 6, 12};
	int[] files2 = {20, 4, 8, 2};
	int[] files3 = {1, 2, 5, 10, 35, 89};
	int[] files4 = {2, 2, 3, 3};
	System.out.println(mergeFiles(files1));
	System.out.println(mergeFiles(files2));
	System.out.println(mergeFiles(files3));
	System.out.println(mergeFiles(files4));
}

private static int mergeFiles(int[] files) {
	Queue<Integer> minHeap = new PriorityQueue<Integer>();
	for(int f : files) {
		minHeap.offer(f);
	}
	int res = 0;
	while(minHeap.size() > 1) {
		int f1 = minHeap.poll();
		int f2 = minHeap.poll();
		int tmp = f1 + f2;
		res += tmp;
		minHeap.offer(tmp);
	}
	return res;
}



------------------------------------------------------------------------------------------------------------------------------
Treasure Island / Min Distance to Remove the Obstacle

You have a map that marks the location of a treasure island. Some of the map area has jagged rocks and dangerous reefs. Other areas are safe to sail in. There are other explorers trying to find the treasure. So you must figure out a shortest route to the treasure island.

Assume the map area is a two dimensional grid, represented by a matrix of characters. You must start from the top-left corner of the map and can move one block up, down, left or right at a time. The treasure island is marked as X in a block of the matrix. X will not be at the top-left corner. Any block with dangerous rocks or reefs will be marked as D. You must not enter dangerous blocks. You cannot leave the map area. Other areas O are safe to sail in. The top-left corner is always safe. Output the minimum number of steps to get to the treasure.

Example:

Input:
[['O', 'O', 'O', 'O'],
 ['D', 'O', 'D', 'O'],
 ['O', 'O', 'O', 'O'],
 ['X', 'D', 'D', 'O']]

Output: 5
Explanation: Route is (0, 0), (0, 1), (1, 1), (2, 1), (2, 0), (3, 0) The minimum route takes 5 steps.


import java.util.*;

public class Main {
    public static int treasureIsland(char[][] island) {
        if (island == null || island.length == 0) return 0;

        int steps = 0;
        Queue<int[]> queue = new LinkedList<>();
        queue.add(new int[]{0,0});
        int[][] dirs = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

        // bfs
        while (!queue.isEmpty()) {
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                int[] cur = queue.poll();
                for (int[] dir : dirs) {
                    int newX = cur[0] + dir[0];
                    int newY = cur[1] + dir[1];

                    if (newX < 0 || newX == island.length || newY < 0 || newY == island[0].length) continue;
                    if (island[newX][newY] == 'D') continue;
                    if (island[newX][newY] == 'X') return steps + 1;
                    island[newX][newY] = 'D';
                    queue.add(new int[]{newX, newY});
                }
            }
            steps++;
        }
        return 0;
    }

    public static void main(String[] args) {
        char[][] island = new char[][]{
                {'O', 'O', 'O', 'O'},
                {'D', 'O', 'D', 'O'},
                {'O', 'O', 'O', 'O'},
                {'X', 'D', 'D', 'O'}
        };
        int result = treasureIsland(island);
        System.out.println(String.format("%s (expect 5)", result));
    }
}
------------------------------------------------------------------------------------------------------------------------------
Treasure Island II
You have a map that marks the locations of treasure islands. Some of the map area has jagged rocks and dangerous reefs. Other areas are safe to sail in. There are other explorers trying to find the treasure. So you must figure out a shortest route to one of the treasure islands.

Assume the map area is a two dimensional grid, represented by a matrix of characters. You must start from one of the starting point (marked as S) of the map and can move one block up, down, left or right at a time. The treasure island is marked as X. Any block with dangerous rocks or reefs will be marked as D. You must not enter dangerous blocks. You cannot leave the map area. Other areas O are safe to sail in. Output the minimum number of steps to get to any of the treasure islands.

Example:

Input:
[['S', 'O', 'O', 'S', 'S'],
 ['D', 'O', 'D', 'O', 'D'],
 ['O', 'O', 'O', 'O', 'X'],
 ['X', 'D', 'D', 'O', 'O'],
 ['X', 'D', 'D', 'D', 'O']]

Output: 3
Explanation:
You can start from (0,0), (0, 3) or (0, 4). The treasure locations are (2, 4) (3, 0) and (4, 0). 
Here the shortest route is (0, 3), (1, 3), (2, 3), (2, 4).

import java.util.*;

public class Main {
    public static int treasureIslandMultiSource(char[][] map) {
        if (map == null || map.length == 0) return 0;
        int n = map.length, m = map[0].length;
        boolean[][] marked = new boolean[n][m];
        Queue<int[]> queue = new LinkedList<>();

        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                if (map[i][j] == 'S') queue.add(new int[]{i, j});

        int[][] dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

        int step = 0;
        while (!queue.isEmpty()) {
            int size = queue.size();
            for(int k = 0; k < size; k++){
                int[] cur = queue.poll();
                for (int[] dir : dirs){
                    int newX = cur[0] + dir[0];
                    int newY = cur[1] + dir[1];
                    if (newX < 0 || newX == map.length || newY < 0 || newY == map[0].length) continue;
                    if (map[newX][newY] == 'D') continue;
                    if (map[newX][newY] == 'X') return step + 1;

                    queue.add(new int[]{newX, newY});
                }

            }
            step++;

        }

        return 0;
    }

    public static void main(String[] args) {
        char[][] island = new char[][]{
                {'S', 'O', 'O', 'S', 'S'},
                {'D', 'O', 'D', 'O', 'D'},
                {'O', 'O', 'O', 'O', 'X'},
                {'X', 'D', 'D', 'O', 'O'},
                {'X', 'D', 'D', 'D', 'O'}
        };
        int result = treasureIslandMultiSource(island);
        System.out.println(String.format("%s (expect  3)", result));
    }
}
----------------------------------------------------------------------------------------------------------------------------
138. Copy List with Random Pointer
class Solution {
    public Node copyRandomList(Node head) {
        Node cur = head;
        Map<Node,Node> cache = new HashMap<>();
        //#1 crate chache map original -> copy node
        while(cur != null){
            cache.put(cur,new Node(cur.val));
            cur = cur.next;
        }
        // #2 connecting next ref and rand ref base on original Node connections
        cur = head;
        Node copyNode = null;
        while(cur != null){
            copyNode = cache.get(cur);
            copyNode.next = cache.get(cur.next);
            copyNode.random = cache.get(cur.random);
            cur = cur.next;
        }
        return cache.get(head);
    }
}
---------------------------------------------------------------------------------------------------------------------------------
21. Merge Two Sorted Lists
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
//         PriorityQueue<ListNode> minHeap = new PriorityQueue<>((a,b)-> a.val - b.val);
//         if(l1 != null) minHeap.add(l1);
//         if(l2 != null) minHeap.add(l2);
//         ListNode head = null;
//         ListNode prev = null;
//         ListNode cur = null;
//         while(!minHeap.isEmpty()){
//             cur = minHeap.poll();
//             // note how to link current with next
//             if(head == null){
//                 head = cur;
//                 prev = cur;
//             }else{
//                 prev.next = cur;
//                 prev = cur;
//             }
//             if(cur.next != null){
//                 minHeap.add(cur.next);
//             }
            
//         }
//         return head;
        
        
        // faster approch
        
        ListNode dummyHead = new ListNode(-1);
        ListNode cur = dummyHead;
        ListNode l = l1;
        ListNode r = l2;
        while(l != null && r != null){
            if(l.val > r.val){
                cur.next = r;
                cur = cur.next;
                r = r.next;
            }else{
                cur.next = l;
                cur = cur.next;
                l = l.next;
            }
        }
        
        while(l != null){
             cur.next = l;
             cur = cur.next;
             l = l.next;
        }
         while(r != null){
             cur.next = r;
             cur = cur.next;
             r = r.next;
        }
        return dummyHead.next;
    }
}
------------------------------------------------------------------------------------------------------------------------------------
572. Subtree of Another Tree

public class Solution {
    public boolean isSubtree(TreeNode s, TreeNode t) {
        if (s == null) return false;
        if (isSame(s, t)) return true;
        return isSubtree(s.left, t) || isSubtree(s.right, t);
    }    
    private boolean isSame(TreeNode s, TreeNode t) {
        if (s == null && t == null) return true;
        if (s == null || t == null) return false;   
        if (s.val != t.val) return false;
        
        return isSame(s.left, t.left) && isSame(s.right, t.right);
    }
}
Time complexity : O(m*n)O(m∗n). In worst case(skewed tree) traverse function takes O(m*n)O(m∗n) time.
Space complexity : O(n)O(n). The depth of the recursion tree can go upto nn. nn refers to the number of nodes in ss.
-------------------------------------------------------------------------------------------------------------------------------------
240. Search a 2D Matrix II
Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:

Integers in each row are sorted in ascending from left to right.
Integers in each column are sorted in ascending from top to bottom.


public class Solution {
    public boolean searchMatrix(int[][] matrix, int target) {
        if(matrix == null || matrix.length < 1 || matrix[0].length <1) {
            return false;
        }
        int col = matrix[0].length-1;
        int row = 0;
        while(col >= 0 && row <= matrix.length-1) {
            if(target == matrix[row][col]) {
                return true;
            } else if(target < matrix[row][col]) {
                col--;
            } else if(target > matrix[row][col]) {
                row++;
            }
        }
        return false;
    }
}

--------------------------------------------------------------------------------------------------------------------------------------
59. Spiral Matrix II
public class Solution {
    public int[][] generateMatrix(int n) {
        // Declaration
        int[][] matrix = new int[n][n];
        
        // Edge Case
        if (n == 0) {
            return matrix;
        }
       
        // Normal Case
        int rowStart = 0;
        int rowEnd = n-1;
        int colStart = 0;
        int colEnd = n-1;
        int num = 1; //change
        
        while (rowStart <= rowEnd && colStart <= colEnd) {
            for (int i = colStart; i <= colEnd; i ++) {
                matrix[rowStart][i] = num ++; //change
            }
            rowStart ++;
            for (int i = rowStart; i <= rowEnd; i ++) {
                matrix[i][colEnd] = num ++; //change
            }
            colEnd --;
            for (int i = colEnd; i >= colStart; i --) {
                if (rowStart <= rowEnd)
                    matrix[rowEnd][i] = num ++; //change
            }
            rowEnd --;
            for (int i = rowEnd; i >= rowStart; i --) {
                if (colStart <= colEnd)
                    matrix[i][colStart] = num ++; //change
            }
            colStart ++;
        }
        return matrix;
    }
}
------------------------------------------------------------------------------------------------------------------------------------
 OA 2019 | Point of Lattice
     int[] lattice(int ax, int ay, int bx, int by) {
        int dx = bx - ax, dy = by - ay;
        // rotate 90
        int rx = dy, ry = -dx;
        // reduce
        int gcd = Math.abs(gcd(rx, ry));
        rx /= gcd;
        ry /= gcd;
        return new int[]{bx + rx, by + ry};
    }

    private int gcd(int x, int y) {
        return y == 0 ? x : gcd(y, x % y);
    }
    
    GCD calculation is O(log (min(x, y))
 -----------------------------------------------------------------------------------------------------------------------------------
 56. Merge Intervals
 class Solution {
    public int[][] merge(int[][] intervals) {
        if(intervals.length == 0) return new int[0][0];
        Arrays.sort(intervals,(a,b)-> a[0] - b[0]);
        int start = intervals[0][0];
        int end = intervals[0][1];
        
        List<int[]> result = new ArrayList<>();
        
        for(int i = 1; i < intervals.length; i++){
            if(end >= intervals[i][0]){// overlap
                end = Math.max(intervals[i][1], end);
            }else{
                // none overlap
                result.add(new int[]{start,end});
                
                start = intervals[i][0];
                end = intervals[i][1];
            }
        }
        result.add(new int[]{start,end});
        int [][] res = new int[result.size()][2];
        for (int i = 0; i < result.size(); i++) {
            res[i] = result.get(i);
        }
        return res;
    }
}

-------------------------------------------------------------------------------------------------------------------------------------
Subtree with Maximum Average

Given an N-ary tree, find the subtree with the maximum average. Return the root of the subtree.
A subtree of a tree is the node which have at least 1 child plus all its descendants. The average value of a subtree is the sum of its values, divided by the number of nodes.

Example 1:

Input:
       20
      /   \
   12     18
  /  |  \   / \
11   2   3 15  8

Output: 18
Explanation:
There are 3 nodes which have children in this tree:
12 => (11 + 2 + 3 + 12) / 4 = 7
18 => (18 + 15 + 8) / 3 = 13.67
20 => (12 + 11 + 2 + 3 + 18 + 15 + 8 + 20) / 8 = 11.125

18 has the maximum average so output 18.
import java.util.*;

public class Main {
    static class Node {
        public int val;
        public List<Node> children;
        public Node() {}
        public Node(int val) { val = val; }
        public Node(int val, List<Node> children) {
            val = val;
            children = children;
        }
    }

    double max;
    Node maxNode;

    public Node getMaximumAverage(Node root) {
        maxNode = null;
        max = Double.MIN_VALUE;

        helper(root);
        return maxNode;
    }

    public double[] helper(Node root) {
        if(root == null) return new double[]{0, 0};
        double count = 1;
        double sum = root.val;

        if(root.children != null) {
            for(Node child: root.children) {
                double[] cur = helper(child);
                sum += cur[0];
                count += cur[1];
            }
        }
        double average = sum / count;
        if(count > 1 && average > max) {
            max = average;
            maxNode = root;
        }
        return new double[]{sum, count};
    }

    public static void main(String[] args) {
        // Input:
        //              20
        //            /   \
        //          12     18
        //       /  |  \   / \
        //     11   2   3 15  8
        Node left = new Node(12);
        left.children = Arrays.asList(new Node(11), new Node(2), new Node(3));

        Node right = new Node(18);
        right.children = Arrays.asList(new Node(15), new Node(8));

        Node root = new Node(20);
        root.children = Arrays.asList(left, right);

        test(root); // output: 18
    }

    private static void test(Node root) {
        Node maxNode = new Main().getMaximumAverage(root);
        System.out.println("Max Average: " + maxNode.val);
    }
}
-------------------------------------------------------------------------------------------------------------------------------------
957. Prison Cells After N Days
class Solution {
    public int[] prisonAfterNDays(int[] cells, int N) {
		if(cells==null || cells.length==0 || N<=0) return cells;
        boolean hasCycle = false;
        int cycle = 0;
        HashSet<String> set = new HashSet<>(); 
        for(int i=0;i<N;i++){
            int[] next = nextDay(cells);
            String key = Arrays.toString(next);
            if(!set.contains(key)){ //store cell state
                set.add(key);
                cycle++;
            }
            else{ //hit a cycle
                hasCycle = true;
                break;
            }
            cells = next;
        }
        if(hasCycle){
            N%=cycle;
            for(int i=0;i<N;i++){
                cells = nextDay(cells);
            }   
        }
        return cells;
    }
    
    private int[] nextDay(int[] cells){
        int[] tmp = new int[cells.length];
        for(int i=1;i<cells.length-1;i++){
            tmp[i]=cells[i-1]==cells[i+1]?1:0;
        }
        return tmp;
    }
}

------------------------------------------------------------------------------------------------------------------------------------
22. Generate Parentheses
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> ans = new LinkedList<>();
        backTracking("", ans, n, 0, 0);
        return ans;
    }
    
    public void backTracking(String curr, List<String> ans, int n, int left, int right){
        if(right == n){
            ans.add(curr);
            return;
        }
        if(left < n){
            // NOTE: curr when using string, unlike List<> we need add then remove, String is immutable
            backTracking(curr + "(", ans, n, left + 1, right); 
        }
        if(right < left){
             backTracking(curr + ")", ans, n, left, right + 1);
        }
    }
}
 
-------------------------------------------------------------------------------------------------------------------------------------
all Questions
https://leetcode.com/discuss/interview-question/344650/Amazon-Online-Assessment-Questions
