Async/Sync VS Blocking/Non-blocking 
    Main difference: Callee & Caller 

    1) Async/Sync: Whether or not Caller will wait for Callee to finish callee's execution. 
        Sync means Caller will wait for Callee to finish 
        Async means Caller will NOT wait for Callee to finish and Caller continue to execute

    2) Blocking/Non-blocking: Whether or not Callee will return immediately to Caller. 
        Blocking means Callee will NOT return immediately to Caller, Callee will execute its logic then return result to Caller.
        Non-Blocking means Callee will return immediately to Caller, Callee will return immediately back to Caller (Callee might be half way on its execution OR not        yet started OR finish execuate its logic)




Reactive Programming
    
    - Observable + Subscriber + Subscription
    
    - Functional Programming
    
    - CompleteFuture vs Reactor
        CompleteFuture
            It will create a sub thread to execute the subtask immediately
        Reactor
            it will create a subthread to execute the subtask only when it is subscribed(Lazy)

    - BackPressure:
        Senerio:
        The speed that data pushed by publisher is faster than subscriber can pull
        
        If we imagine we were being streamed tweets from twitter, it would then be up to the upstream(Services send tweets) to decide what to do. If tweets were coming in but there are no requests from the downstream(Services consume the tweets), then the upstream could drop items, store them in a buffer, or some other strategy.

        Essentially, this is reactive pull backpressure. We are requesting the upstream(producer) to only push a certain amount of elements, and only when we are ready.



Spring MVC
    Request/Response Flow:            |--------------------------------------|
        Request(->)/Response(<-) <->  |Servelet Container(Tomacat) ThreadPool|  <-> thread1 <-> Filter <-> Dispacher Servlet <-> RequestMapping and HandlerMapping <-> Controller <-> Service <-> Remote Database/Remote API       
        Thread Per Request Model: each request come in with one thread to handle
        configure through server.tomcat.max-threads
        by default: 200 concurrent connections
    Issue:
        each thread take some space in memory and horizontal scaling requires more machines(additional cost)
    
Spring WebFlux(Moving away from Thread Per Request Model)
        
