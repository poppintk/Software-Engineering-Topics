Two factor causes OOM: 1) heap size too small 2) memory leak

History:
- Sun Classic VM (Intepreter only) 
- HotSpot VM (Oracle or OpenJDK) 
  - Intereter + JIT (cache hot code) 
- Exact VM
- JRockit VM
- IBM J9 VM
- Azul VM and BEA LiquidVM
- Apache Harmony
- Microsoft JVM
- Taobao JVM

Class Files -> Class Loader subsystem  -> Runtime Data Area -> Execution engine

Hotspot JVM has method Area, Other JVMs don't have it

Class Loader subsystem
  NOTE: ClassLoader only load the class file and whether or not it is excutable depends on Execution Engine
  - Loading
    - binary stream -> method area -> entrace of Class loarder (generate the class in the reflection API)
    - supports:
      - loading from internet
      - loading from local files
      - loading from jar 
      - generated at runtime -> dynamic proxy
  - Linking
    - verify
    - Prepare
    - Resolve
  - Initialization
    - clinit(() class init
  
  - types
    BootstrapClassLoader (default path jre/lib)
            |
    ExtensionClassLoader (default path jre/lib/ext)
            |
    AppClassLoader (default path classpath)
    
    - Bootstrap class loader
      - implemented in C++
      - all java core class(package with java, javax or sun) use the Boostrap class loader. i.e. String.getClassloader() -> null
    - User-defined classloader extends Boostrap class loader 
      - User-defined class loader user system class loarder.  UserDefinedClass.getClassloader() -> app class loader


    -----------------------------------------
    Purpose of JVM performance tuning: reduce OOM(out of memory) and full GC cycle in order to improve response time and throughput
    
    How?
      1) Performance monitoring
        - GC cycle high frequency
        - CPU load too high
        - OOM
        - Memory leak
        - Dead lock
        - Program response time too long
       2) performance analyze
        - utilize command tools like jstack, jmap, jinfo 
        - dump out stack file and use memory tools analyze the file
        - use Ali Arthas or Jconsole, JVisualVM to check JVM condition
        - Jstack check stack information
       3) Perforamnce tuning
        - add apporprate member size and choose right GC base on scenerio
        - optimizing code and controll the memory usage 
        - add more machine and reduce nodes pressue
        - set apporprate number of threads
        - use the middleware to increase program efficiency like Cache or MQ
        
    Performance Metrics
      - Response time
      - throughput
        in GC, total running time = program running time + GC running time
        throughput is 1 - 1/(1 + n). -XX:GCTimeRatio=n
      - currency
      - memory(Stack) usage
------------------------------------------------------------------------------
Tools command line
  - jps: check JVM running process 
  - jstat: monioring all running status, it can show local/remote process class load, memory usage, GC and JIT compile information
    - options
      class load: -class 
      GC: 
        -gc parameters (jstat -gc, -gcutil, -gccause)
          - SOC: the first Survivor section size in bytes
          - S1C: the second Survivor section size in bytes
          - S0U: the first Survivor section used size in bytes
          - S1U: the second Survivor section used size in bytes
          - EC: The Eden section size in bytes
          - EU: The Eden section used size in bytes

          - OC: The Old section size in bytes
          - OU: The Old section used size in bytes

          - MC: The method section size in bytes
          - MU: The method section used size
          - CCSC: The compressed class section size
          - CCSU: The compressed class section used size

          - YGC: The number of Young GC since running
          - YGCT: The young gc time consumption 
          - FGC: The number of Full GC since running
          - FGCT: The Full GC time consumption
          - GCT: The total time of GC

          expereince: percentage ratio = (row1.GCT - row2.GCT) / (row1.program running time - row2.program running time)
          if percentage ratio is greater than 20%, it means our heap memory under pressure. if this value is beyond 90% then
          The OOM is likely happen any soon

          How to detect memory leak?
          
          use find minmium value of OU from different time interval, if the OU sample value keeps increasing. it means there is potential
          memory leak issue

      JIT: 
        -compiler 
        -printcompliation

  - jinfo: real time checking and modifying JVM configuration, can used for checking default settings

  - jmap: export memory image file and memory usage
    - options:
      - dump: generate dump file
        - manually, jmap -dump:live,format=b,file=<FILE_LOCATION>
        - automatically, -XX:HeapDumpPath=<FILE_LOCATION> AND -XX:+HeapDumpOnOutMemoryError
      - heap: output all heap memory space info
      - histo: output heap mempry space statics info
      NOTE: jmap vs jstat jmap time point and jstat on time interval

  - jhat: JDK heap analyze tool(used with jmap)
    -removed in JDK9 JDK10, prefer VisualVM

  - jstack: generate snapshot of stack of each thread
    - great for detect dead lock

  - jcmd: can do everything above except jstack

  use jps to get the process id and use jstat to show details
      
------------------------------------------------------------------------------
GUI Tools
  JDK
  - jConsole
  - VisualVM
  - JMC
  
  - eclipse MAT
  - JProfiler
  - Arthas
  - Java Mission Control
  - Btrace
  - Flame Graphs
  
  
  
  
