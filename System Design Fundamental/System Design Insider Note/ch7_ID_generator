Step 1 - Understand the problem and establish design scope
  Candidate: What are the characteristics of unique IDs? Interviewer: IDs must be unique and sortable.
  Candidate: For each new record, does ID increment by 1?
  Interviewer: The ID increments by time but not necessarily only increments by 1. IDs created in the evening are larger than those created in the morning on the same day.
  Candidate: Do IDs only contain numerical values? Interviewer: Yes, that is correct.
  Candidate: What is the ID length requirement? Interviewer: IDs should fit into 64-bit.
  Candidate: What is the scale of the system?
  Interviewer: The system should be able to generate 10,000 IDs per second.
  
  requirements are listed as follows:
  • IDs must be unique.
  • IDs are numerical values only.
  • IDs fit into 64-bit.
  • IDs are ordered by date.
  • Ability to generate over 10,000 unique IDs per second.
  
Step 2 - Propose high-level design and get buy-in
  Multiple options can be used to generate unique IDs in distributed systems. The options we considered are:
  • Multi-master replication
    - uses the databases’ auto_increment feature.Instead of increasing the next ID by 1, we increase it by k, where k is the number of database servers in use
    - some major drawbacks:
      • Hard to scale with multiple data centers
      • IDs do not go up with time across multiple servers. (cannot sort by time)
      • It does not scale well when a server is added or removed.
  • Universally unique identifier (UUID)
    UUID is a 128-bit number used to identify information in computer systems.
      Pros:
      • Generating UUID is simple. No coordination between servers is needed so there will not be any synchronization issues.
      • The system is easy to scale because each web server is responsible for generating IDs they consume. ID generator can easily scale with web servers.
      Cons:
      • IDs are 128 bits long, but our requirement is 64 bits. 
      • IDs do not go up with time. (cannot sort by time)
      • IDs could be non-numeric.
      
  • Ticket server
    The idea is to use a centralized auto_increment feature in a single database server (Ticket Server)
    Pros:
    • Numeric IDs.
    • It is easy to implement, and it works for small to medium-scale applications.
    Cons:
    • Single point of failure. Single ticket server means if the ticket server goes down, all systems that depend on it will face issues. To avoid a single point of failure, we can set up multiple ticket servers. However, this will introduce new challenges such as data synchronization.
  • Twitter snowflake approach
    
     1 bit |   41 bits  |   5 bits       | 5 bits     |  12 bits        | 
    |-------------------------------------------------------------------|
    | 0    |  timestamp | data center ID | machine ID | sequence number |
    |-------------------------------------------------------------------|
    
    • Sign bit: 1 bit. It will always be 0. This is reserved for future uses. It can potentially be used to distinguish between signed and unsigned numbers.
    • Timestamp: 41 bits. Milliseconds since the epoch or custom epoch. We use Twitter snowflake default epoch 1288834974657, equivalent to Nov 04, 2010, 01:42:54 UTC.
    • Datacenter ID: 5 bits, which gives us 2 ^ 5 = 32 datacenters.
    • Machine ID: 5 bits, which gives us 2 ^ 5 = 32 machines per datacenter.
    • Sequence number: 12 bits. For every ID generated on that machine/process, the sequence number is incremented by 1. The number is reset to 0 every millisecond.
    
Step 3 - Design deep dive
