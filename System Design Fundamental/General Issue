Distributed environment
   Sychronization issue
      When multiple instances are used, then it is important to study whether there is issue that mapping to a different instance as before. 
      Distributed session issue, it's example of this issue
      
      Solution:
         1) ensure request is alwasy mapping to same instance as before
            - sticky session (idea ensure)
            - consistent hashing
         2) create a global unique instance
            - we could use some consensus algorithm to ensure instance act like one machine
         
   Race Condition/concurrent issue
      case that under high concurrency (multiple request in any order), the ouput is randomly generated depends the which
      operation go in first (like Redis for example, GET and INCRE are separate operations if not using LUA script then item could be not increment appropriate)
      
      Solutions:
         - Distributed lock -> low performance
         - Distributed Transaction
      
   Distributed transaction issue
      Under distributed environment, one operation contains multiple DB objects
       Solutions:
         - Distributed Transaction




Oauth2 flow for web server:
   1) client browser click on the Oauth2 login icon, Request to third party for the login with redirect URL(for web server)
   2) Users input their third party login
   3) After authenticate third party authorization server redirect back to the URL(web server) with access token(code)
   4) The web server now can call POST request ask for public protected user information. Note the POST body requires access token(code) just return
   CLIENT_ID, CLIENT_KEY those can be access from the third party
   5) public protected information is returned
   
   
      
      
 SMS API protection:
      Why? public API need be called too often
      - one workable solution is use Redis to save key-value pair key is the phone number and the value is SMS code + current system time
      - Rate limiter can also work
    
          

Scaling
   - sharding is great for scaling write.
   - for scaling read, might not needed because we can use cache for this feature
