Distributed Data

Scalability 
Fault Tolerance/Availability - Replication
Delay - Applications are deployed on the data center that closer to users 


Shared-nothing architecture == horizontal scale == scale out

Replica VS Partitioning

Purpose of replica
  1) geographcally distributed(close to user so that reduce latency)
  2) High availability
  3) scale for reading 

three popular replication algorithm:
  1) single leader
  2) multi-leader
  3) leaderless

leader-base replication OR master/slave replication
  - one of repilica is leader and insert data send to leader then send data change(replication log or change stream) to all replicas
  - replicas are read replicas
  - clients can read data from leader or replicas, only the leader can do the write operation

  - some of databases uses: PostgreSQL, MySQL, MongoDB, RethinkDB and ESpresso
  - some of middlewares uses: Kafka and RabbitMQ

How to replica change? sync vs async (most of database hardcoded in one of them)
  Replication asynchronously will cause eventually consitent issue
  Replication synchronously will cause entire system slow or stop
  semi-synchronous: one of follow is replication synchronously and rest of the replications are 
  done asynchronously. if current synchronous replication become unavailable then choose one from asynchronous replications become the new synchronous replications

Set up new replication
  1) get db snapshot from master db.
  2) copy data from db snapshot to new replicaiton
  3) connect new replication to the master db and pull from log sequence offset number from the db
    (in PostgreSQL it is sequence nubmer LSN AND in MySQL it's binlog)

Replication out of sync
  from replica log can figure out the last transaction, so replica can connect to master and request
  all data changes after last transaction.

Master unavailable
  - choose a new leader from replicas and "failover" from its relicas need to be done.
  1) confirm master is unavailable , most system use timeout, if no response time out for example over 30 sec
  we think master is unavailable.
  2) choose a new leader, new leader node is the node has newst data replica. let all the nodes agree the new leader
  . Here we need consense algorithm like raft
  3) reconfigure system allow client to send write request to new leader node. if old leader come back, it might still
  think it's the master. system need to make sure old leader ackowledge the new leader and old leader become the new slave

failover issues might occus:
  1) if use async replication, the new master might lose the last data from old master.
  The reason is new master is chosen from the outdated salves. and now old master come back. 
  old master contains additional updated information than new master, it ends up with conflict for new master to write.
  How to resolve such issue?
  Simply discard the changes in old master, but it will break durable expectation
  
  2) timeout too short might cause unnecessary failover
  3) too nodes think they are the leader- Split Brain


Replication Log implementation
  All implemented by Database System
  1) Statement Based Replication
    - Nondeterministic statement like Now() will generate different effect on differnt replica
    - AUTO INCREMENT or UPDATE...WHERE <SOME CONDITION> need to make sure they get excuted at same order 
    - Side effect statement like (trigger, user defined function) might have different side effect on each replicas
    - too many edge cases
  
  2) WAL(Write Ahead Log)
    - send WAL to replicas and replicas apply WAL 
    - Disavantage is that WAL is low level design usually decoupled with storage engine and difference in each version. As result end up 
    more complexity on operation
    
  3) Logical Log Replication (Record Row Base Replication)
    - example MySQL BinaryLog

  4) Trigger based Replication
    



