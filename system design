Distributed Cache:

Use case:
system requires low real-time and allow eventually consistent

Common cache system issues:
1)缓存雪崩 Cache Avalanche
   All cache keys TTL expires at the same time, So all the requests go to DB => DB down
   Solution: Adding randomly TTL to the cache keys

2)缓存穿透 Cache Penetration
  User requests the key does not exist on the DB, so the key must not in the cache as well, So all the requests go to DB => DB down
  Solution: 1)Bloom Filter 2) Allowing null as value to the cache key and also setup TTL.     
  
3)缓存击穿 Hotspot Invalid
  There are hot data that User keep requesting to the cache(large QPS), right at the point of time TTL get expired, Soall requests go to DB => DB down 
  Solution: Use locks, if distributed then use distributed locks
  
  
Cache update issues:
   Double write: when data is updated, write to update both DB and cache. 
   Lazy Loading: when data is updated, firstly update DB data then delete cache.
   under high concurrency senerio both cases will cause data inconsistency. adding TTL to make it eventually consistent.
   
  
Distributed Lock (Redison - Redis based distributed lock framework)
   - Reentrance Lock
   - ReadWrite Lock
   - Semaphore
   - CountDownLatch
   
   
Distributed Session issue:
   1) cannot share on different domain
   2) Load balancing to arbitrary machine and that machine not guarrantee have the previous stored session
