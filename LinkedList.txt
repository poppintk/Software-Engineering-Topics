234. Palindrome Linked List

// assume ListNode is Single Linked List Node


ListNode fast = head;
ListNode slow = head;
1) increase by two
// note
// "fast.next != null" works on odd length, even length error.
// "fast != null" works on even length , odd length error.
while(fast != null && fast.next != null){// note: missing either one condition will crash for arbitrary size of length
    fast = fast.next.next;
    slow = slow.next;
}
// if size is odd, fast will be the last node and slow will be on index Math.floor(size/2)
// if size is even, fast will be null pointer at the end and slow will be on index size/2
// 876. Middle of the Linked List

2) increase by one
while(fast != null){
  fast = fast.next
}
 
//note: following code will missing one more case for fast != null,
// in such a code, don't forget process bussiness logic for last LinkedList node
while(fast.next != null){
  fast = fast.next
}
// exit condition: fast.next = null
// so we missing case fast != null
// note: need to check edge case fast is null, otherwise break the code


3) reverse LinkedList
we need three references: prev,cur and next.
before update cur.next reference, we store cur.next old reference in next variable


ListNode prev = null;
ListNode cur = slow;
ListNode next = null;

while(cur != null){
    next = cur.next;
    cur.next = prev;
    prev = cur;
    cur = next;
}
// note: end of loop, prev is now new head for reversed LinkedList
// note: when reversing LinkedList, or deleting node including head we need dummyNode, always use dummy node. 
// see lc for dummy Node 92. Reverse Linked List II 
// 83. Remove Duplicates from Sorted List
// 82. Remove Duplicates from Sorted List II
// 61. Rotate List
// 86. Partition List
// 143. Reorder List
// 328. Odd Even Linked List
// 141. Linked List Cycle
// 142. Linked List Cycle II
