Differences between TreeMap, HashMap and LinkedHashMap in Java
HashMap: HashMap offers 0(1) lookup and insertion. 
If you iterate through the keys, though, the ordering of the keys is essentially arbitrary. 
It is implemented by an array of linked lists.
•	A HashMap contains values based on the key.
•	It contains only unique elements.
•	It may have one null key and multiple null values.
•	It maintains no order.
•	It is not-thread safe
HashSet internally uses HashMap for storing objects


LinkedHashMap: LinkedHashMap offers 0(1) lookup and insertion. 
Keys are ordered by their insertion order. 
It is implemented by doubly-linked buckets.
•	A LinkedHashMap contains values based on the key.
•	It contains only unique elements.
•	It may have one null key and multiple null values.
•	It is same as HashMap instead maintains insertion order.
•	It is not-thread safe
LinkedHashSet uses LinkedHashMap internally to store objects


TreeMap: TreeMap offers O(log N) lookup and insertion. 
Keys are ordered, so if you need to iterate through the keys in sorted order, you can. 
This means that keys must implement the Comparable interface. TreeMap is implemented by a Red-Black Tree.

•	It is not-thread safe
•	A TreeMap contains values based on the key. It implements the NavigableMap interface and extends AbstractMap class.
•	It contains only unique elements.
•	It cannot have null key but can have multiple null values.
•	It is same as HashMap instead maintains ascending order(Sorted using the natural order of its key).
TreeSet uses TreeMap internally to store objects


Hashtable: “Hashtable” is the generic name for hash-based maps.
•	A Hashtable is an array of list. Each list is known as a bucket. 
The position of bucket is identified by calling the hashcode() method. A Hashtable contains values based on the key.
•	It contains only unique elements.
•	It may have not have any null key or value.
•	It is synchronized.
•	It is a legacy class.


How Abstraction Works
Abstraction as an OOP concept in Java works by letting programmers create useful, reusable tools. For example, a programmer can create several different types of objects. These can be variables, functions, or data structures. Programmers can also create different classes of objects. These are ways to define the objects.
For instance, a class of variable might be an address. The class might specify that each address object shall have a name, street, city, and zip code. The objects, in this case, might be employee addresses, customer addresses, or supplier addresses.
How Encapsulation Works
Encapsulation lets us re-use functionality without jeopardizing security. It’s a powerful OOP concept in Java because it helps us save a lot of time. For example, we may create a piece of code that calls specific data from a database. It may be useful to reuse that code with other databases or processes. Encapsulation lets us do that while keeping our original data private. It also lets us alter our original code without breaking it for others who have adopted it in the meantime.
How Inheritance Works
Inheritance is another labor-saving Java OOP concept. It works by letting a new class adopt the properties of another. We call the inheriting class a subclass or a child class. The original class is often called the parent. We use the keyword extends to define a new class that inherits properties from an old class.
How Polymorphism Works
Polymorphism in Java works by using a reference to a parent class to affect an object in the child class. We might create a class called “horse” by extending the “animal” class. That class might also implement the “professional racing” class. The “horse” class is “polymorphic,” since it inherits attributes of both the “animal” and “professional racing” class.
Two more examples of polymorphism in Java are method overriding and method overloading.
In method overriding, the child class can use the OOP polymorphism concept to override a method of its parent class. That allows a programmer to use one method in different ways depending on whether it’s invoked by an object of the parent class or an object of the child class.
In method overloading, a single method may perform different functions depending on the context in which it’s called. That is, a single method name might work in different ways depending on what arguments are passed to it.



•	S - Single-responsiblity principle
A class should have one and only one reason to change, meaning that a class should have only one job.

•	O - Open-closed principle
Objects or entities should be open for extension, but closed for modification.

•	L - Liskov substitution principle
All this is stating is that every subclass/derived class should be substitutable for their base/parent class

•	I - Interface segregation principle
A client should never be forced to implement an interface that it doesn't use or clients shouldn't be forced to depend on methods they do not use.

•	D - Dependency Inversion Principle
Entities must depend on abstractions not on concretions. It states that the high level module must not depend on the low level module, but they should depend on abstractions.

DevOps
Plan -> code -> build-> test-> release -> deploy-> operate-> monitor



Q: What does yield method of the Thread class do?
Ans: A yield () method moves the currently running thread to a  runnable state and allows the other threads for execution. So that equal priority threads have a chance to run. It is a static method. It doesn’t release any lock.
Yield () method moves the thread back to the Runnable state only, and not the thread to sleep (), wait () (or) block.


Q #38) What is a Thread?
Ans: In Java, the flow of a execution is called Thread. 
Every java program has at least one thread called main thread, 
the Main thread is created by JVM. 
The user can define their own threads by extending Thread class (or) by implementing Runnable interface. 
Threads are executed concurrently.

Q #39) How do you make a thread in Java?
#1) Extend Thread class:
Extending a Thread class and override the run method. The thread is available in java.lang.thread.
Example:
Public class Addition extends Thread {
  public void run () {
    //todo
  }
}
#2) Implement Runnable interface:
Another way is implementing the runnable interface. For that we should provide the implementation for run () method which is defined in the interface.
Example:
Public class Addition implements Runnable {
  public void run () {
    //todo
  }
}

Q #40) Explain about join () method.
Ans: Join () method is used to join one thread with the end of the currently running thread.
Example:
public static void main (String[] args){
  Thread t = new Thread ();
  t.start ();
  t.join ();// Once it reaches the code t.join() then main thread started the execution.
  // main thread will contious to run...
}
Q #42) Explain about wait () method.
Ans: wait () method is used to make the thread to wait in the waiting pool. When a wait () method is executed during a thread execution
then immediately the thread gives up the lock on the object and goes to the waiting pool.
Wait () method tells the thread to wait for a given amount of time.

Then the thread will wake up after notify () (or) notify all () method is called.
Wait() and the other above-mentioned methods do not give the lock on the object immediately until the currently executing thread completes the synchronized code. 
It is mostly used in synchronization.
Example:
public static void main (String[] args){
  Thread t = new Thread ();
  t.start ();
  Synchronized (t) {
    Wait();
  }
}

Q #48) Explain thread life cycle in Java.
Ans: Thread has the following states:
New
Runnable
Running
Non-runnable (Blocked)
Terminated
Thread Life Cycle in JAVA

New:
In New state, Thread instance has been created but start () method is not yet invoked. Now the thread is not considered alive.

Runnable:
The Thread is in runnable state after invocation of the start () method, 
but before the run () method is invoked. 
But a thread can also return to the runnable state from waiting/sleeping. In this state the thread is considered alive.

Running:
The thread is in running state after it calls the run () method. Now the thread begins the execution.

Non-Runnable(Blocked):
The thread is alive but it is not eligible to run. It is not in runnable state but also, it will return to runnable state after some time.
Example: wait, sleep, block.

Terminated :
Once the run method is completed then it is terminated. Now the thread is not alive.

wait() vs sleep()
sleep() is a method which is used to pause the process for few seconds or the time we want to. 
But in case of wait() method, thread goes in waiting state and it won’t come back automatically until we call the notify() or notifyAll().

The major difference is that wait() releases the lock or monitor while sleep() doesn’t releases the lock or monitor while waiting.
wait() is used for inter-thread communication while sleep() is used to introduce pause on execution, generally.

JAVA 8 new features
Lambda expressions,
Method references,
Functional interfaces,
Stream API,
Default methods,
Static methods in interface,
Optional class,
Collectors class,
ForEach() method,
Type and Repating Annotations

Microservice
- load balancer
- Service registration and discovery
- Service-to-service calls
 RPC(remote procedure call)
- logging and monitoring
- Leadership election and cluster management
- route gateway routing
- global locks
- Distributed messaging

CompletableFuture in Java 8
working nonblocking for main thread when there is many dependable tasks to run. 


Java 7 uses Dual-Pivot Quicksort for primitives and TimSort for objects.
Timsort is a hybrid "merge sort and insertion sort."
JAVA 8 also offer parallel sort()

