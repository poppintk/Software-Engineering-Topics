Hashmap vs Hashtable
1. HashMap is non synchronized. It is not-thread safe and can’t be shared between many threads without proper synchronization code whereas Hashtable is synchronized. It is thread-safe and can be shared with many threads.
2. HashMap allows one null key and multiple null values whereas Hashtable doesn’t allow any null key or value.
3. HashMap is generally preferred over HashTable if thread synchronization is not needed
Why HashTable doesn’t allow null and HashMap does?
To successfully store and retrieve objects from a HashTable, the objects used as keys must implement the hashCode method and the equals method. Since null is not an object, it can’t implement these methods. HashMap is an advanced version and improvement on the Hashtable. HashMap was created later.


Differences between TreeMap, HashMap and LinkedHashMap in Java
HashMap: HashMap offers 0(1) lookup and insertion. If you iterate through the keys, though, the ordering of the keys is essentially arbitrary. It is implemented by an array of linked lists.
•	A HashMap contains values based on the key.
•	It contains only unique elements.
•	It may have one null key and multiple null values.
•	It maintains no order.
•	It is not-thread safe
HashSet internally uses HashMap for storing objects


LinkedHashMap: LinkedHashMap offers 0(1) lookup and insertion. Keys are ordered by their insertion order. It is implemented by doubly-linked buckets.
•	A LinkedHashMap contains values based on the key.
•	It contains only unique elements.
•	It may have one null key and multiple null values.
•	It is same as HashMap instead maintains insertion order.
•	It is not-thread safe
LinkedHashSet uses LinkedHashMap internally to store objects


TreeMap: TreeMap offers O(log N) lookup and insertion. Keys are ordered, so if you need to iterate through the keys in sorted order, you can. This means that keys must implement the Comparable interface. TreeMap is implemented by a Red-Black Tree.

•	It is not-thread safe
•	A TreeMap contains values based on the key. It implements the NavigableMap interface and extends AbstractMap class.
•	It contains only unique elements.
•	It cannot have null key but can have multiple null values.
•	It is same as HashMap instead maintains ascending order(Sorted using the natural order of its key).
TreeSet uses TreeMap internally to store objects


Hashtable: “Hashtable” is the generic name for hash-based maps.
•	A Hashtable is an array of list. Each list is known as a bucket. The position of bucket is identified by calling the hashcode() method. A Hashtable contains values based on the key.
•	It contains only unique elements.
•	It may have not have any null key or value.
•	It is synchronized.
•	It is a legacy class.


How Abstraction Works
Abstraction as an OOP concept in Java works by letting programmers create useful, reusable tools. For example, a programmer can create several different types of objects. These can be variables, functions, or data structures. Programmers can also create different classes of objects. These are ways to define the objects.
For instance, a class of variable might be an address. The class might specify that each address object shall have a name, street, city, and zip code. The objects, in this case, might be employee addresses, customer addresses, or supplier addresses.
How Encapsulation Works
Encapsulation lets us re-use functionality without jeopardizing security. It’s a powerful OOP concept in Java because it helps us save a lot of time. For example, we may create a piece of code that calls specific data from a database. It may be useful to reuse that code with other databases or processes. Encapsulation lets us do that while keeping our original data private. It also lets us alter our original code without breaking it for others who have adopted it in the meantime.
How Inheritance Works
Inheritance is another labor-saving Java OOP concept. It works by letting a new class adopt the properties of another. We call the inheriting class a subclass or a child class. The original class is often called the parent. We use the keyword extends to define a new class that inherits properties from an old class.
How Polymorphism Works
Polymorphism in Java works by using a reference to a parent class to affect an object in the child class. We might create a class called “horse” by extending the “animal” class. That class might also implement the “professional racing” class. The “horse” class is “polymorphic,” since it inherits attributes of both the “animal” and “professional racing” class.
Two more examples of polymorphism in Java are method overriding and method overloading.
In method overriding, the child class can use the OOP polymorphism concept to override a method of its parent class. That allows a programmer to use one method in different ways depending on whether it’s invoked by an object of the parent class or an object of the child class.
In method overloading, a single method may perform different functions depending on the context in which it’s called. That is, a single method name might work in different ways depending on what arguments are passed to it.



•	S - Single-responsiblity principle
A class should have one and only one reason to change, meaning that a class should have only one job.

•	O - Open-closed principle
Objects or entities should be open for extension, but closed for modification.

•	L - Liskov substitution principle
All this is stating is that every subclass/derived class should be substitutable for their base/parent class

•	I - Interface segregation principle
A client should never be forced to implement an interface that it doesn't use or clients shouldn't be forced to depend on methods they do not use.

•	D - Dependency Inversion Principle
Entities must depend on abstractions not on concretions. It states that the high level module must not depend on the low level module, but they should depend on abstractions.

DevOps
Plan -> code -> build-> test-> release -> deploy-> operate-> monitor



Q: What does yield method of the Thread class do?
Ans: A yield () method moves the currently running thread to a  runnable state and allows the other threads for execution. So that equal priority threads have a chance to run. It is a static method. It doesn’t release any lock.
Yield () method moves the thread back to the Runnable state only, and not the thread to sleep (), wait () (or) block.
