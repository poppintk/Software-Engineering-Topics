79. Word Search
class Solution {
    public boolean exist(char[][] board, String word) {
        int rows = board.length;
        int cols = board[0].length;
  
        for(int i = 0; i< rows; i++){
            for(int j = 0; j < cols;j++){
                if(backTracking(board,word,0,i,j)) return true;
            }
        }
        return false;
    }
    
    public boolean backTracking(char[][] board, String word,int index,int i,int j){
        int rows = board.length;
        int cols = board[0].length;
        // search range space
        // choice spaces
        if(i < 0 || i == rows || j < 0 || j == cols) return false;
        
        // constraints: not allowing
        if(board[i][j] != word.charAt(index)) return false;
        
        // goal
        if(index == word.length() - 1) return true;
    
        
        board[i][j]^= 256;
        boolean ans = backTracking(board,word,index+1,i+1,j) ||
            backTracking(board,word,index+1,i-1,j)||
            backTracking(board,word,index+1,i,j+1)||
            backTracking(board,word,index+1,i,j-1);
        board[i][j]^= 256;
        return ans;
  
    }
}

Time complexity:
search: O(4^l) where l = len(word)
total: O(m*n*4^l)

Space complexity:
O(m*n + l)


END 79. Word Search
-----------------------------------------------------------------------------------------------------------------------------
200. Number of Islands.(connected components pattern)

class Solution {
    public int numIslands(char[][] grid) {
        
        int row = grid.length;
        if(row == 0) return 0;
        int col = grid[0].length;
        
        int count = 0;
        
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j ++){
                if(grid[i][j] == '1'){
                    count +=1;
                    dfs(grid, i, j);
                }
            }
        }
        return count;
    }
    
    public void dfs(char[][] grid, int i,int j){
        int row = grid.length;
        int col = grid[0].length;
        if(i == row || i < 0 || j < 0 || j == col || grid[i][j] == '0') return;
        grid[i][j] = '0';
        dfs(grid,i + 1,j);
        dfs(grid,i - 1,j);
        dfs(grid,i,j + 1);
        dfs(grid,i,j - 1);
        
    }
}

Time complexity:
total: O(m*n)
Space comlexity:
O(1)

END 200. Number of Islands
-----------------------------------------------------------------------------------------------------------------------------
547. Friend Circles (connected components pattern)
class Solution {
    public int findCircleNum(int[][] M) {
        int row = M.length;
        int count = 0;
        Set<Integer> visited = new HashSet<>();
        
        for(int i = 0; i < row; i++){
            if(visited.contains(i)) continue;
            dfs(M,visited, i);
            count++;
        }
        
        return count;
    }
    
    public void dfs(int[][] M, Set<Integer> visited,int cur){
        if(visited.contains(cur)) return;
        visited.add(cur);
        // for all current's friend
        for(int i = 0; i < M.length; i++){
            if(M[cur][i] == 1 && !visited.contains(i)){
                dfs(M,visited, i);
            }
        }
        
    }
}

Time complexity:
total: O(N^2)
Space comlexity:
O(N)


END 547. Friend Circles
----------------------------------------------------------------------------------------------------------------------------

Combination vs Permutation

perm(nums, depth, n, used, curr, ans):
    if depth==n:
        ans.append(curr)
        return
    
    for i = 0 to len(nums):
        if used[i]: continue
        used[i] = True
        curr.push(nums[i])
        perm(nums, d+1, n, curr, ans)
        curr.pop()
        used[i] = False
        
        
combination(nums, depth, n, start, curr, ans):
    if depth == n:
        ans.append(curr)
        return
        
    for i = start to len(nums):
        curr.push(nums[i])
        combination(nums, depth + 1, n, i+1, curr, ans)
        curr.pop()
        
