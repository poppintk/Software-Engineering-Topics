200题每个grid只能属于一个connected component，一旦第一次被访问到就算找到组织（解）了，不能再被其他联通分量使用。
对于79题，如果当前路径无解，最后一个字符其实被没有被使用到，所以退栈前需要还原，那么其他路径就可以使用了

对于DFS来说绝大对数的情况下是需要还原的，因为没找到解。这个类型题目的时间复杂度通常为为O(n!) O(2^n) 或者 O(c^n)。
只有找连通分量(connected component)/拓扑排序(topological sort)的时候不需要还原，时间复杂度为O(V+E)

79. Word Search
class Solution {
    public boolean exist(char[][] board, String word) {
        int rows = board.length;
        int cols = board[0].length;
  
        for(int i = 0; i< rows; i++){
            for(int j = 0; j < cols;j++){
                if(backTracking(board,word,0,i,j)) return true;
            }
        }
        return false;
    }
    
    public boolean backTracking(char[][] board, String word,int index,int i,int j){
        int rows = board.length;
        int cols = board[0].length;
        // search range space
        // choice spaces
        if(i < 0 || i == rows || j < 0 || j == cols) return false;
        
        // constraints: not allowing
        if(board[i][j] != word.charAt(index)) return false;
        
        // goal
        if(index == word.length() - 1) return true;
    
        
        board[i][j]^= 256;
        boolean ans = backTracking(board,word,index+1,i+1,j) ||
            backTracking(board,word,index+1,i-1,j)||
            backTracking(board,word,index+1,i,j+1)||
            backTracking(board,word,index+1,i,j-1);
        board[i][j]^= 256;
        return ans;
  
    }
}

Time complexity:
search: O(4^l) where l = len(word)
total: O(m*n*4^l)

Space complexity:
O(1)


END 79. Word Search
-----------------------------------------------------------------------------------------------------------------------------
200. Number of Islands.(connected components pattern)

class Solution {
    public int numIslands(char[][] grid) {
        
        int row = grid.length;
        if(row == 0) return 0;
        int col = grid[0].length;
        
        int count = 0;
        
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j ++){
                if(grid[i][j] == '1'){
                    count +=1;
                    dfs(grid, i, j);
                }
            }
        }
        return count;
    }
    
    public void dfs(char[][] grid, int i,int j){
        int row = grid.length;
        int col = grid[0].length;
        if(i == row || i < 0 || j < 0 || j == col || grid[i][j] == '0') return;
        grid[i][j] = '0';
        dfs(grid,i + 1,j);
        dfs(grid,i - 1,j);
        dfs(grid,i,j + 1);
        dfs(grid,i,j - 1);
        
    }
}

Time complexity:
total: O(m*n)
Space comlexity:
O(1)

END 200. Number of Islands
-----------------------------------------------------------------------------------------------------------------------------
547. Friend Circles (connected components pattern)
class Solution {
    public int findCircleNum(int[][] M) {
        int row = M.length;
        int count = 0;
        Set<Integer> visited = new HashSet<>();
        
        for(int i = 0; i < row; i++){
            if(visited.contains(i)) continue;
            dfs(M,visited, i);
            count++;
        }
        
        return count;
    }
    
    public void dfs(int[][] M, Set<Integer> visited,int cur){
        if(visited.contains(cur)) return;
        visited.add(cur);
        // for all current's friend
        for(int i = 0; i < M.length; i++){
            if(M[cur][i] == 1 && !visited.contains(i)){
                dfs(M,visited, i);
            }
        }
        
    }
}

Time complexity:
total: O(N^2)
Space comlexity:
O(N)


END 547. Friend Circles
----------------------------------------------------------------------------------------------------------------------------
130. Surrounded Regions
class Solution {
    public void solve(char[][] board) {
        int row = board.length;
        if(row == 0) return;
        int col = board[0].length;
        
        // mark first col and last col if exist 'O' into 'G'
        for(int r = 0; r < row; r++){
            dsf(board,r,0);
            dsf(board,r,col-1);
        }
        // mark first row and last row if exist 'O' into 'G'
        for(int c = 0; c < col; c ++){
            dsf(board,0,c);
            dsf(board,row-1,c);
        }
        
        for(int i = 0; i < row; i ++){
            for(int j = 0; j < col; j++){
                if(board[i][j] == 'G') board[i][j] = 'O';
                else if(board[i][j] == 'O') board[i][j] = 'X';
                
            }
        }
    }
    
    public void dsf(char[][] board,int i, int j){
        int row = board.length;
        int col = board[0].length;
        if(i < 0 || i >= row || j <0 || j >= col || board[i][j] != 'O') return;
        //NOTE:  board[i][j] == 'X' will cause overflow
        
        board[i][j] = 'G';
        dsf(board,i-1,j);
        dsf(board,i+1,j);
        dsf(board,i,j+1);
        dsf(board,i,j-1);   
    }

}

Time complexity:
total: O(MN)
Space comlexity:O(MN)


END 130. Surrounded Regions
-----------------------------------------------------------------------------------------------------------------------------
52. N-Queens II
class Solution {
    
    Integer count = 0;
    Set<Integer> col = new HashSet<>();
    Set<Integer> diag1 = new HashSet<>();
    Set<Integer> diag2 = new HashSet<>();
    
    public int totalNQueens(int n) {
        char[][] board = generateBoard(n);
        solveQueen(board, n, 0);
        return count;
    }
    
    public char[][] generateBoard(int n){
        char[][] board = new char[n][n];
        for(int i = 0; i < n; i++){
            for(int j = 0; j < n; j++){
                board[i][j] = '.';
            }
        }
        return board;
    }
    
    public void placeQueen(char[][] board, int n, int i, int j){
        col.add(j);
        diag1.add(i + j);
        diag2.add(j - i + (n - 1));
        board[i][j] = 'Q';
    }
    
    public void removeQueen(char[][] board, int n, int i, int j){
        col.remove(j);
        diag1.remove(i+j);
        diag2.remove(j - i + (n - 1));
        board[i][j] = '.';
    }
    
    public boolean isInvalid(char[][] board, int n, int i, int j){
        return col.contains(j) || diag1.contains(i+j) || diag2.contains(j - i + (n - 1));
    }
    
    public void solveQueen(char[][] board, int n, int i){
        if(i == n){
            count ++;
            return;
        }// goal
        
        // for every column
        for(int j = 0; j < n; j++){
            if(isInvalid(board,n,i,j)) continue; // constraint
            placeQueen(board,n,i,j);
            solveQueen(board, n, i+1);
            removeQueen(board,n,i,j);
        }
    }
}

Time complexity:
total: exponential time
Space comlexity:O(n*n + 3n)

END 52. N-Queens II
---------------------------------------------------------------------------------------------------------------------------


Combination vs Permutation

perm(nums, depth, n, used, curr, ans):
    if depth==n:
        ans.append(curr)
        return
    
    for i = 0 to len(nums):
        if used[i]: continue
        used[i] = True
        curr.push(nums[i])
        perm(nums, d+1, n, curr, ans)
        curr.pop()
        used[i] = False
        
        
combination(nums, depth, n, start, curr, ans):
    if depth == n:
        ans.append(curr)
        return
        
    for i = start to len(nums):
        curr.push(nums[i])
        combination(nums, depth + 1, n, i+1, curr, ans)
        curr.pop()
        
        
  
