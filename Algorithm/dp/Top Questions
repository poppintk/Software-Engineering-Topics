划分型  
139 word break
279. Perfect Squares
91. Decode Ways

坐标型  
動態規劃方程f[i]中的下標i 表示以 序列[i] 為結尾的滿足條件的子序列的性質. f[i][j]中的下標i, j 表示以格子(i,j)為結尾的滿足條件的路徑的性質
-最大值/最小值
-個數
-是否存在

120. Triangle
55. Jump Game (This can be improved by using greedy)
152. Maximum Product Subarray
63. Unique Paths II  
62. Unique Paths
64. Minimum Path Sum

序列型
前i個。。 遵守某種序列規則 最小/方式數/可行性
256. Paint House （515. Paint House）

雙序列型
72. Edit Distance
10. Regular Expression Matching

背包型 Unbound Knapsack

322. Coin Change

983. Minimum Cost For Tickets

92.BackPack (lintcode) each item only used once 
可行性背包
求不超過Target時拼出的最大重量
State: dp[i][w] = 前i個物品能不能拼出重量w
init: dp[0][0] = true; dp[0][1...w] = false;
这道题不能用 先sort 在找sum 的方式， 因为最大值可能不是来自连续的序列

計數型背包
求有多少種方式拼出重量target
State: dp[i][w] = 前i個物品有多少種方式拼出重量w
init: dp[0][0] = 1; dp[0][1...w] = 0;
無value/price demension
563. Backpack V (lintcode) items only used once, Find the number of possible fill the backpack
564. Backpack VI / Combination Sum IV (lintcode),each item can be used many times. find the number of possible combinations that add up to a weight w

最值型背包
求能拼出的最大價值
State: dp[i][w] = 前i個物品拼出重量w能得到的最大價值
init: dp[0][0] = 0; dp[0][1...w] = -1;//價值為-1表示不可能
125. Backpack II, items only used once,What's the maximum value can you put into the backpack?
Backpack III



位操作型

