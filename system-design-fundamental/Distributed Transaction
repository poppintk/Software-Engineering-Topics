
## Local Transaction

Data inconsistant issue with local transactional rollback on Exception

Assume we have three service : A,B and C
their calling chain is A -> B -> C
example :
in A service 
processA() {
  doSomeWork();
  B();
  C();
}

1) if call B() RPC fail we can throw Exception to trigger rollback,
but what if B() just network delay? in that case, if B has change someting in the DB and we rollback changes on A.
This will be issue. Because we expect all should rollback.

2) calling failed on C(), in such case B(0 will never rollback

network delay issue + distributed machine => Distributed Transaction

Local Transaction
ACID
1) Atomicity
2) Consistency
A:1000 B: 1000 => A transfer 100 to B => A:900 B:1000. Violates consistency because before transfer,A + B = 2000 and after transfer A + B = 1900
3) Isolation
4) Durability: As long as transaction commit, data should be on the disk

On local transaction, mutlple operations share the same connection to database, so any exception occurs we can rollback all operations on database


Isolation level (Ranking lowest to highest):
  1) Read Uncommited
  2) Read Commited
  3) Repeatable Read(MySQL default)
  4) Serializable
  
Spring local transaction propagation -> determine whether or not inside the methods call should share a transaction or separate transaction

Spring @transactional drawback:
  1) Under same class transactional methods call each, transactional only work for transactional method at top level, all transaction setting 
  like propagation and timeout setting will not take affect for lower level transaction mothods, because @transactional use proxy pattern.
  How to resolve? Use proxy object to call tranction method. use <spring-boot-starter-apo> see #284 for detail
  
  
  ## Distributed Transaction
  
  CAP theorem
  
  C - Consistency
    All system nodes at the same time should keep same value
  A - Availability
    Service node(s) goes down, system still operate as usual
  P - Partition tolerance
    Separate system into different region like one data center in China and one in US
    The system continues to operate despite an arbitrary number of messages being dropped (or delayed) by the network between nodes,
    continue to provide consistency and availability
  
  
  in distribute system, we gurrantee AP and CP because P is required for most of the distributed system
  It's impossible to maintained CA distributed system, like everything in a single machine.(Not a distributed system)
  
  Raft algorithm gurrantee CP
  http://thesecretlivesofdata.com/raft/
  
  # Issue CP
  For most large distributed system(Ecommerce like Amazon) in industry, required AP and sacrifice Consistency. Because availibity is more important than consistency
  
  # BASE theorem
  Extension to the CAP. The idea is for the most of distributed system, 
  we cannot gurrantee the strong consistency, but can gurrantee the weak consistency and eventually consistency.
  
    1) Basically Available (BA)
      Allowing some of the system lose availability (like response time increase). Note system is not absolutely unvailalbe
    
    2) Soft State(S)
      true - have data
      false - not exist data
      middle state - data replication
      The system existing middle state and this middle state will not impact on system availability. Time delay on sync replication. MySQL async replication is also a example 
    
    3) Eventual Consistency(E)
      Eventually consistency is special case of weak consistency
      
  
  
  # Strong consistency, weak consistency and strong consistency
  
  1ï¼‰Strong consistency
    After inserting/updating data, following reading must have the most recent updated data 
  2) Weak consistency
    After inserting/updating data, following reading allow to have time delay to get the most recent updated data OR the following reading cannot get the most recent updated data
  3) Eventually consistency
    After inserting/updating data, following reading allow to have time delay to get the most recent updated data.
    
    
  # Distributed transaction 
  1) 2PC(2 phase commit) refer #287 
    - Seata implementation
    - Not great for high concurrent system, low performance
    - 3PC 
  2) TCC (Try Confirm Cancel)
    - Hard transaction: follow ACID theorem, Strong consistency
    - Soft transaction: follow BASE theorem, Weak consistency
    - need developer to develope three logic Try, Confirm and Cancel
    
  3) Soft Transaction - use MQ try best to send, if failed retry (Allow high concurrent)
  4) Soft Transaction - MQ + Eventually consistency(Async confirmation)  (Allow high concurrent)
  
  
 
