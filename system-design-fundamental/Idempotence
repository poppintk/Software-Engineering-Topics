1) What is Idempotence?
one or more request to API and generate the same output. For example users click on payment, no matter how many times users clicks on it and it will not cause double pay.
* Retry and distributed system is key factor cause the Idemopotence

2) Use case:
  1) users click on payment button
  2) url return back the payment url
  3) Microservices RPC call with retry (retry will cause Idemotence)

3) SQL and Idempotence:
  SQL is idempotence in many operations, but not all operation are idempotence.
  Example idemotence operation:
    SELECT * FROM table WHERE id=? 
    UPDATE table SET col1=1 WHERE cols2=2
    DELETE FROM user WHERE useid=1 
    INSERT INTO USER(userid, name) VALUES（1,'a') only if userid is primary key
    
  Example NOT idemotence operation:
    UPDATE table SET col1=col1+1 WHERE col2=2 
    INSERT INTO user(userid, name) VALUES(1,'a') if user id is not primary key and allow duplicate then each time insert will create new record with different id
    

4) Idempotence solutions:
  1) Token mechanism
    a) Server provide token API, and those token generated by server will be saved into Redis. When some bussiness logic requires idempotence, call to get the token.
    b) After getting the token then calling the target API with token (usually token in the request header)
    c) The server will check whether token is stored in Redis or not, if exist then it's first time， then delete token and continue execute logic.
    d) If token is not stored in Redis => it's duplicated operation
    
    Redis: KEY: TOKEN_PREFIX + user_id  VALUE: UUID, TTL: 30 mins etc
    
    Note:
      1 delete token firstly or delete token afterwards
        1) delete afterwards, bussiness logic ran, but network delay, no token is deleted => request is double executed
        2) it is better delete token first, if calling failed, just re-calling request to get token 
      2 token GET and DELETE must be atomic operation
        String luaScript = "if redis.call(\"get\", KEYS[1]) == ARGV[1] then return redis.call(\"del\", KEYS[1]) else return 0 end";
        Note: if return 0 then no bussness logic should be executed.
  2) All locking mechanism
    a) Optimistic Concurrency Control
      select * from XXX where id=1 for update;
      
    b) Optimistic Concurrency Control
      update goods set count = count - 1, verison = version + 1 where good_id = 2 and version = 1
      use case: good for read more write less issue
      
    c) Distributed locks
      if more chaines need to process same data at the time, we can use distributed lock to check if data already process.
      
  3) Unique constraint
    1) database unique constraint
    
    2) Redis set
    
  4) Table for preventing duplicates
  
  5) Request globally unique id
    
